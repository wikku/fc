% vim: et
Specification "fc".

Define rfloat : ((val -> expr) -> expr) -> ((val -> expr) -> expr) -> prop by
  rfloat (t\ let E T) (t\ let E T);
  rfloat (t\ let (let E T1) (T2 t)) (t\ let E (T' t)) := nabla x, rfloat (t\ let (T1 x) (T2 t)) (t\ T' t x);
  rfloat (t\ let E (T t)) (t\ let E (T' t)) := nabla x, rfloat (t\ T t x) (t\ T' t x).

Define float : expr -> ((val -> expr) -> expr) -> prop by
  float E (t\ let E t);
  float (let E L) (t\ let E (L' t)) := nabla x, float (L x) (t\ L' t x).

Define mfloat : expr -> ((val -> expr) -> expr) -> prop by
  mfloat E (t\ let E t) := forall E' T', E = let E' T' -> false;
  mfloat (let E L) (t\ let E (L' t)) := nabla x, mfloat (L x) (t\ L' t x).

Theorem float_subv : forall E L U, nabla (x : val), float (E x) (L x) -> float (E U) (L U).
  induction on 1.
  intros. case H1.
    search.
    apply IH to H2 with U = U. search.

Define par : expr -> expr -> prop,
       parv : val -> val -> prop by

  nabla x, parv x x;
  parv (lam E) (lam E') := nabla x, par (E x) (E' x);

  par (app (lam E) V) (E' V') := parv V V' /\ nabla x, par (E x) (E' x);
  par (delim (ret V)) (ret V') := parv V V';

  par (let E T) (L' T') := exists E',  nabla x, par E E' /\ par (T x) (T' x) /\ float E' L';
  par (app V U) (app V' U') := parv V V' /\ parv U U';
  par (delim E) (delim E') := par E E';
  par (shift0 E) (shift0 E') := nabla k, par (E k) (E' k);
  par (ret V) (ret V') := parv V V';
  nabla k, par (k (E k)) (k (E' k)) := nabla k, par (E k) (E' k).


Theorem pars_subv :
  (forall E E' U U', nabla x, par (E x) (E' x) -> parv U U' -> par (E U) (E' U')) /\
  (forall V V' U U', nabla x, parv (V x) (V' x) -> parv U U' -> parv (V U) (V' U')).
%  (forall T T' U U', nabla x, part (T x) (T' x) -> parv U U' -> part (T U) (T' U')).
  induction on 1 1. split.
  intros. case H1.
    apply IH1 to H3 H2. apply IH to H4 H2. search.
    apply IH1 to H3 H2. search.
    apply IH to H3 H2. apply IH to H4 H2. apply float_subv to H5 with U = U'. search.
    apply IH1 to H3 H2. apply IH1 to H4 H2. search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.
    apply IH1 to H3 H2. search.
    apply IH to H3 H2. search.
  intros. case H1.
    search.
    search.
    apply IH to H3 H2. search.

Split pars_subv as par_subv, parv_subv, part_subv.

Theorem rfloat_ass : forall L L' M M', nabla x, rfloat L L' -> rfloat (M x) (M' x) -> rfloat (t\ L' x\ M x t) (t\ L' x\ M' x t).
  induction on 1. intros.
  case H1.
    search.
    permute (n1 n2) H2. apply IH to H3 H2. search.
    permute (n1 n2) H2. apply IH to H3 H2. search.


Theorem float_ass : forall A B L M, nabla x, float A L -> float (B x) (M x) -> float (L B) (t\ L (y\ M y t)).
  induction on 1. intros.
  case H1.
    search.
    permute (n1 n2) H2. apply IH to H3 H2. search.

Define parl : ((val -> expr) -> expr) -> ((val -> expr) -> expr) -> prop by
  parl (t\ let E t) (t\ let E' t) := par E E';
  parl (t\ let E (T t)) (t\ let E' (T' t)) := par E E' /\ nabla x, parl (t\ T t x) (t\ T' t x).

Theorem float_par : forall E E' L, par E E' -> float E L -> exists L', float E' L' /\ forall T T', nabla x, par (T x) (T' x) -> par (L T) (L' T').
  induction on 2. intros.
  case H2 (keep).
    search.
    case H1. apply IH to H5 H3. apply float_ass to H6 H7. exists t\L'1 y\L'2 y t. split. search. intros. permute (n1 n2) H10. apply H8 to H10. search.

%Theorem float_par2 : forall E E' L L' T T', nabla x, par E E' -> float E L -> float E' L' -> par (T x) (T' x) -> par (L T) (L' T').
%  induction on 2. intros.
%  case H2 (keep).
%    search.
%    case H1. case H3.
%      skip. % reject by asserting L' longer than L
%
%
%      
%      
%    Quit.

%Theorem float_par2 : forall E E' L L' T T', nabla x, par E E' -> float E' L' -> par (T x) (T' x) -> par (L T) (L' T').
%  induction on 2. intros.
%  case H2 (keep).
%    
%    Quit.

%Theorem float_par : forall E E' L, par E E' -> float E L -> exists L', mfloat E' L' /\ forall T T', nabla x, par (T x) (T' x) -> par (L T) (L' T').
%  induction on 1. intros.
%  case H2.
%    Quit.
%    search.
%    case H1. apply IH to H5 H3. apply float_ass to H6 H7. exists t\L'1 y\L'2 y t. split. search. intros. permute (n1 n2) H10. apply H8 to H10. search.

%Theorem float_val : forall E1 E2 E L1 L2, par E1 E -> par E2 E -> float E1 L1 -> float E2 L2 -> exists L, forall T T', nabla x, par (T x) (T' x) -> par (L2 T) (L T') /\ par (L1 T) (L T').
%  induction on 3. intros.
%  case H3.
%    case H4.
%      search.
%      case H2. apply float_par to H7 H5. apply float_ass to H8 H9. exists t\L'1 y\L'2 y t. intros. split. permute (n1 n2) H12. apply H10 to H12. search. search.
%    case H4.
%      case H1. apply float_par to H7 H5. apply float_ass to H8 H9. exists t\L'1 y\L'2 y t. intros. split. search. permute (n1 n2) H12. apply H10 to H12. search.
%      case H1. case H2. %apply float_par to H12 H6. apply float_par to H8 H5.
%  skip.

%Theorem float_diag : forall E L1 L2, float E L1 -> float E L2 -> exists L, float E L /\

%Theorem floats : forall E L1 L2, float E L1 -> float E L2 -> exists E' L L', nabla (x : val),
%    (L1 = t\ L (x\ let E' (t x)) /\ float E' L' /\ L2 = t\ L (x\ L' (t x))) \/
%    (L2 = t\ L (x\ let E' (t x)) /\ float E' L' /\ L1 = t\ L (x\ L' (t x))).
%  induction on 1. intros.
%  case H1.
%    case H2.

Define tle : ((val -> expr) -> expr) -> ((val -> expr) -> expr) -> prop by
  tle (t\ let E t) T := float E T;
  tle (t\ let E (T1 t)) (t\ let E (T2 t)) := nabla x, tle (t\ T1 t x) (t\ T2 t x).

Theorem tle : forall E L1 L2, float E L1 -> float E L2 -> tle L1 L2 \/ tle L2 L1.
  induction on 1. intros.
  case H1.
    case H2.
      search.
      search.
    case H2.
      search.
      apply IH to H3 H4. case H5. search. search.

%Define floatle : expr -> ((val -> expr) -> expr) -> ((val -> expr) -> expr) -> prop by
%  floatl E (t\ let E t);
%  float (let E L) (t\ let E (L' t)) := nabla x, float (L x) (t\ L' t x).

%Theorem par_float : forall E E',
%
%Theorem par_tle : forall E T L1 L2, tle L1 L2 -> par E (L1 T) -> par E (L2 T).
%  induction on 1. intros.
%  case H1.
%    case H3.
%      search.
%


Theorem pars_diam :
  (forall E E1 E2, par E E1 -> par E E2 -> exists E3, par E1 E3 /\ par E2 E3) /\
  (forall V V1 V2, parv V V1 -> parv V V2 -> exists V3, parv V1 V3 /\ parv V2 V3).
  induction on 1 1. split.
  intros. case H1.
    case H2.
      apply IH1 to H3 H5. apply IH to H4 H6. apply par_subv to H9 H7. apply par_subv to H10 H8. search.
      case H5. apply IH1 to H3 H6. apply IH to H4 H7. apply par_subv to H10 H8. search.
    case H2.
      apply IH1 to H3 H4. search.
      case H4. apply IH1 to H3 H5. search.
    case H2. apply IH to *H3 *H6. apply IH to *H4 *H7. apply float_par to H9 H5. apply float_par to H10 H8. apply tle to H13 H15.
      
    Quit.
    case H2.% case H5.
    Quit.
      case H8.
        apply IH to H3 H6. apply IH to H4 H7. search.
        apply IH to H3 H6. apply IH to H4 H7. case H11. permute (n1 n2) H13. apply float_par_comm to H9 H15 H13. apply float_ass to H16 H18. search.
      case H8.
        apply IH to H3 H6. apply IH to H4 H7. case H10. permute (n1 n2) H12. apply float_par_comm to H9 H15 H12. apply float_ass to H16 H18. search.
        apply IH to *H3 *H6. apply IH to *H4 *H7. case H11. case H12.
            % permute (n1 n2) H13. permute (n1 n2) H14. apply float_par_comm to H9 H16 H13. apply float_par_comm to H10 H19 H14.
            %permute (n1 n2) H13. permute (n1 n2) H14. apply float_par_comm to *H9 *H16 *H13. apply float_par_comm to *H10 *H19 *H14.
            %apply float_ass to H17 H22. apply float_ass to H20 H24.
            % have: float E'2 L D6, float E' L1 D6. NO!
            % need: par (LT n1) (LT' n1), par (LT1 n1) (LT1' n1), float E'2 LT' E3, float E'3 LT1' E3
            Quit.
            apply float_val to H17 H20 H22 H24. search.
    case H2.
      case H3. apply IH1 to H4 H5. apply IH to H7 H6. apply par_subv to H11 H9. search.
      apply IH1 to H3 H5. apply IH1 to H4 H6. search.
    case H2.
      case H3. apply IH1 to H5 H4. search.
      apply IH to H3 H4. search.
    case H2. apply IH to H3 H4. search.
    case H2. apply IH1 to H3 H4. search.
    case H2. apply IH to H3 H4. search.
  intros. case H1.
    case H2. search.
    case H2. apply IH to H3 H4. search.
