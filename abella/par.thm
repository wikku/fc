% vim: et
Specification "fc".

Kind skel type.
Type sk0 skel.
Type sk1 skel -> skel.
Type sk2 skel -> skel -> skel.

Define skel : skel -> prop by
  skel sk0;
  skel (sk1 S) := skel S /\ forall S1 S2, S = sk2 S1 S2 -> skel (sk1 S2);
  skel (sk2 S1 S2) := skel S1 /\ skel S2 /\ forall S11 S12, S1 = sk2 S11 S12 -> skel (sk2 S12 S2).

Define eos : expr -> skel -> prop,
       vos : val -> skel -> prop by
  nabla x, vos x sk0;
  vos (lam E) (sk1 S) := nabla x, eos (E x) S;

  eos (ret V) (sk1 S) := vos V S;
  eos (app V1 V2) (sk2 S1 S2) := vos V1 S1 /\ vos V2 S2;
  eos (let E T) (sk2 S1 S2) := eos E S1 /\ nabla x, eos (T x) S2;
  eos (shift0 E) (sk1 S) := nabla k, eos (E k) S;
  eos (delim E) (sk1 S) := eos E S;
  nabla k, eos (k (E k)) (sk1 S) := nabla k, eos (E k) S.

Define float : expr -> (val -> expr) -> expr -> prop by
  float E T (let E T);
  float (let E L) T (let E LT) := nabla x, float (L x) T (LT x).

Theorem float_subv : forall E T LET U, nabla (x : val), float (E x) (T x) (LET x) -> float (E U) (T U) (LET U).
  induction on 1.
  intros. case H1.
    search.
    apply IH to H2 with U = U. search.

Define par : expr -> expr -> prop,
       parv : val -> val -> prop by

  nabla x, parv x x;
  parv (lam E) (lam E') := nabla x, par (E x) (E' x);

  par (app (lam E) V) (E' V') := parv V V' /\ nabla x, par (E x) (E' x);
  par (delim (ret V)) (ret V') := parv V V';

  par (let E T) LET' := exists E' T', nabla x, par E E' /\ par (T x) (T' x) /\ float E' T' LET';
  par (app V U) (app V' U') := parv V V' /\ parv U U';
  par (delim E) (delim E') := par E E';
  par (shift0 E) (shift0 E') := nabla k, par (E k) (E' k);
  par (ret V) (ret V') := parv V V';
  nabla k, par (k (E k)) (k (E' k)) := nabla k, par (E k) (E' k).



Theorem pars_subv :
  (forall E E' U U', nabla x, par (E x) (E' x) -> parv U U' -> par (E U) (E' U')) /\
  (forall V V' U U', nabla x, parv (V x) (V' x) -> parv U U' -> parv (V U) (V' U')).
  induction on 1 1. split.
  intros. case H1.
    apply IH1 to H3 H2. apply IH to H4 H2. search.
    apply IH1 to H3 H2. search.
    apply IH to H3 H2. apply IH to H4 H2. apply float_subv to H5 with U = U'. search.
    apply IH1 to H3 H2. apply IH1 to H4 H2. search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.
    apply IH1 to H3 H2. search.
    apply IH to H3 H2. search.
  intros. case H1.
    search.
    search.
    apply IH to H3 H2. search.

Split pars_subv as par_subv, parv_subv.

%Theorem pars_diam :
%  (forall S E E1 E2, skel S -> eos E S -> par E E1 -> par E E2 -> exists E3, par E1 E3 /\ par E2 E3) /\
%  (forall S V V1 V2, skel S -> vos V S -> parv V V1 -> parv V V2 -> exists V3, parv V1 V3 /\ parv V2 V3).
%  induction on 1 1. split.
%  intros. case H3.
%    case H2. case H1. case H7. case H9. case H4.
%      apply IH to H14 _ H5 H17. apply H11 to _. apply IH to H21 _ H6 H18. search.
%      apply H11 to _.

%Theorem wrap_let : forall E T LET' L L', nabla x, par (let E T) LET' -> par (L x) (L' x) -> par (let E x\ let (T x) L) (let LET' L').
%  induction on 1.
%  intros. case H1.
%    skip.
%    search.
% false

Theorem float_ass : forall A B C AB BC, nabla x, float A B AB -> float (B x) C (BC x) -> exists ABC, float AB C ABC /\ float A BC ABC.
  induction on 1.
  intros. case H1.
    search.
    permute (n1 n2) H2. apply IH to H3 H2. search.

Theorem float_par_comm : forall E E' T T' LET, nabla x, float E T LET -> par E E' -> par (T x) (T' x) -> exists LET', par LET LET' /\ float E' T' LET'.
  induction on 1. intros.
  case H1.
    search.
    case H2. permute (n1 n2) H3. apply IH to H4 H6 H3. apply float_ass to H7 H9. search.

Theorem float_eq :
  (forall E1 E2 E T1 T2 T LET1 LET2, nabla x, float E1 T1 LET1 -> float E2 T2 LET2 -> par E1 E -> par E2 E -> par (T1 x) (T x) -> par (T2 x) (T x) -> exists E3, par LET1 E3 /\ par LET2 E3) /\
  (forall E1 E2 E T1 T2 T LET1 LET2, nabla x, float E1 T1 LET1 -> float E2 T2 LET2 -> par E1 E -> par E2 E -> par (T1 x) (T x) -> par (T2 x) (T x) -> exists E3, par LET1 E3 /\ par LET2 E3).
  induction on 1 2. split.
  intros. case H1.
    case H2.
      search.
      case H4. permute (n1 n2) H6. apply float_par_comm to H7 H9 H6. apply float_ass to H10 H12. search.
    case H2.
      case H3. permute (n1 n2) H5. apply float_par_comm to H7 H9 H5. apply float_ass to H10 H12. search.
      %case H3. case H4.
      %permute (n1 n2) H5. permute (n1 n2) H6. apply float_par_comm to H7 H10 H5. apply float_par_comm to H8 H13 H6. apply float_ass to H11 H16. apply float_ass to H14 H18.
        % need: float E' LET' E1 /\ float E'1 LET'1 E1

    
  Quit.


Theorem pars_diam :
  (forall E E1 E2, par E E1 -> par E E2 -> exists E3, par E1 E3 /\ par E2 E3) /\
  (forall V V1 V2, parv V V1 -> parv V V2 -> exists V3, parv V1 V3 /\ parv V2 V3).
  induction on 1 1. split.
  intros. case H1.
    case H2.
      apply IH1 to H3 H5. apply IH to H4 H6. apply par_subv to H9 H7. apply par_subv to H10 H8. search.
      case H5. apply IH1 to H3 H6. apply IH to H4 H7. apply par_subv to H10 H8. search.
    case H2.
      apply IH1 to H3 H4. search.
      case H4. apply IH1 to H3 H5. search.
    case H2. apply IH to H3 H6. apply IH to H4 H7. apply float_par_comm to H5 H9 H11. apply float_par_comm to H8 H10 H12.
    Quit.
    case H2.
      case H3. apply IH1 to H4 H5. apply IH to H7 H6. apply par_subv to H11 H9. search.
      apply IH1 to H3 H5. apply IH1 to H4 H6. search.
    case H2.
      case H3. apply IH1 to H5 H4. search.
      apply IH to H3 H4. search.
    case H2. apply IH to H3 H4. search.
    case H2. apply IH1 to H3 H4. search.
    case H2. apply IH to H3 H4. search.
  intros. case H1.
    case H2. search.
    case H2. apply IH to H3 H4. search.
  intros. case H1.
    case H2.
      apply IH to H5 H6. search.
      case H5. 
    
