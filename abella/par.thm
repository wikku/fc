% vim: et
Specification "fc".

Kind skel type.
Type sk0 skel.
Type sk1 skel -> skel.
Type sk2 skel -> skel -> skel.

Define skel : skel -> prop by
  skel sk0;
  skel (sk1 S) := skel S /\ forall S1 S2, S = sk2 S1 S2 -> skel (sk1 S2);
  skel (sk2 S1 S2) := skel S1 /\ skel S2 /\ forall S11 S12, S1 = sk2 S11 S12 -> skel (sk2 S12 S2).

Define eos : expr -> skel -> prop,
       vos : val -> skel -> prop by
  nabla x, vos x sk0;
  vos (lam E) (sk1 S) := nabla x, eos (E x) S;

  eos (ret V) (sk1 S) := vos V S;
  eos (app V1 V2) (sk2 S1 S2) := vos V1 S1 /\ vos V2 S2;
  eos (let E T) (sk2 S1 S2) := eos E S1 /\ nabla x, eos (T x) S2;
  eos (shift0 E) (sk1 S) := nabla k, eos (E k) S;
  eos (delim E) (sk1 S) := eos E S;
  nabla k, eos (k (E k)) (sk1 S) := nabla k, eos (E k) S.

Define par : expr -> expr -> prop,
       parv : val -> val -> prop,
       parl : expr -> ((val -> expr) -> expr) -> prop by

  nabla x, parv x x;
  parv (lam E) (lam E') := nabla x, par (E x) (E' x);

  nabla t, par (t (V t)) (t (V' t)) := nabla t, parv (V t) (V' t);
  par (let E T) (E' T') := nabla x, parl E E' /\ par (T x) (T' x);
  par (app (lam E) V) (E' V') := parv V V' /\ nabla x, par (E x) (E' x);
  par (delim (ret V)) (ret V') := parv V V';

  par (app V U) (app V' U') := parv V V' /\ parv U U';
  par (delim E) (delim E') := par E E';
  par (shift0 E) (shift0 E') := nabla k, par (E k) (E' k);
  par (ret V) (ret V') := parv V V';
  nabla k, par (k (E k)) (k (E' k)) := nabla k, par (E k) (E' k);

  parl E (t\ let E' t) := par E E';
  parl (let E T) (t\ let E' x\ T' x t) := nabla x, par E E' /\ parl (T x) (T' x);
  parl (ret V) (t\ t V'):= parv V V'.



Theorem pars_subv :
  (forall E E' U U', nabla x, par (E x) (E' x) -> parv U U' -> par (E U) (E' U')) /\
  (forall V V' U U', nabla x, parv (V x) (V' x) -> parv U U' -> parv (V U) (V' U')) /\
  (forall E E' U U', nabla x, parl (E x) (E' x) -> parv U U' -> parl (E U) (E' U')).
  induction on 1 1 1. split.
  intros. case H1.
    apply IH1 to H3 H2. search.
    apply IH2 to H3 H2. apply IH to H4 H2. search.
    apply IH1 to H3 H2. apply IH to H4 H2. search.
    apply IH1 to H3 H2. search.
    apply IH1 to H3 H2. apply IH1 to H4 H2. search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.
    apply IH1 to H3 H2. search.
    apply IH to H3 H2. search.
  intros. case H1.
    search.
    search.
    apply IH to H3 H2. search.
  intros. case H1.
    apply IH to H3 H2. search.
    apply IH to H3 H2. apply IH2 to H4 H2. search.
    apply IH1 to H3 H2. search.

Split pars_subv as par_subv, parv_subv, parl_subv.

Theorem pars_subt :
  (forall E E' T T', nabla t (x : val), par (E t) (E' t) -> par (T x) (T' x) -> par (E T) (E' T')) /\
  (forall V V' T T', nabla t (x : val), parv (V t) (V' t) -> par (T x) (T' x) -> parv (V T) (V' T')) /\
  (forall E E' T T', nabla t (x : val), parl (E t) (E' t) -> par (T x) (T' x) -> parl (E T) (E' T')).
  induction on 1 1 1. split.
  intros. permute (n2 n12) H2. case H1.
    apply IH1 to H3 H2. search.
    apply IH1 to H3 H2. apply par_subv to H2 H4. search.
    apply IH2 to H3 H2. apply IH to H4 H2. search.
    apply IH1 to H3 H2. apply IH to H4 H2. search.
    apply IH1 to H3 H2. search.
    apply IH1 to H3 H2. apply IH1 to H4 H2. search.
    apply IH to H3 H2. search.
    apply IH to H3 H2. search.
    apply IH1 to H3 H2. search.
    apply IH to H3 H2. search.
  intros. permute (n2 n12) H2. case H1.
    search.
    apply IH to H3 H2. search.
  intros. permute (n2 n12) H2. case H1.
    apply IH to H3 H2. search.
    apply IH to H3 H2. apply IH2 to H4 H2. search.
    apply IH1 to H3 H2. search.

Split pars_subt as par_subt, parv_subt, parl_subt.

%Theorem pars_diam :
%  (forall S E E1 E2, skel S -> eos E S -> par E E1 -> par E E2 -> exists E3, par E1 E3 /\ par E2 E3) /\
%  (forall S V V1 V2, skel S -> vos V S -> parv V V1 -> parv V V2 -> exists V3, parv V1 V3 /\ parv V2 V3).
%  induction on 1 1. split.
%  intros. case H3.
%    case H2. case H1. case H7. case H9. case H4.
%      apply IH to H14 _ H5 H17. apply H11 to _. apply IH to H21 _ H6 H18. search.
%      apply H11 to _.

%Theorem wrap_let : forall E T LET' L L', nabla x, par (let E T) LET' -> par (L x) (L' x) -> par (let E x\ let (T x) L) (let LET' L').
%  induction on 1.
%  intros. case H1.
%    skip.
%    search.
% false

Theorem pars_diam :
  (forall E E1 E2, par E E1 -> par E E2 -> exists E3, par E1 E3 /\ par E2 E3) /\
  (forall V V1 V2, parv V V1 -> parv V V2 -> exists V3, parv V1 V3 /\ parv V2 V3) /\
  (forall E E1 E2, parl E E1 -> parl E E2 -> exists E3, nabla t, par (E1 t) (E3 t) /\ par (E2 t) (E3 t)) /\
  (forall E E1 E2, parl E E1 -> par E E2 -> exists E3, nabla t, par (E1 t) (E3 t) /\ parl E2 E3) /\
  (forall E E1 E2, parl E E1 -> par E E2 -> exists E3, nabla t, par (E1 t) (E3 t) /\ parl E2 E3).
  induction on 1 1 1 1 2. split.
  intros. case H1.
    case H2. apply IH1 to H3 H4. search.
    case H2. apply IH2 to H3 H5. apply IH to H4 H6. apply par_subt to H7 H9. apply par_subt to H8 H10. search.
    case H2.
      apply IH1 to H3 H5. apply IH to H4 H6. apply par_subv to H9 H7. apply par_subv to H10 H8. search.
      case H5. apply IH1 to H3 H6. apply IH to H4 H7. apply par_subv to H10 H8. search.
    case H2.
      apply IH1 to H3 H4. search.
      case H4. apply IH1 to H3 H5. search.
    case H2.
      case H3. apply IH1 to H4 H5. apply IH to H7 H6. apply par_subv to H11 H9. search.
      apply IH1 to H3 H5. apply IH1 to H4 H6. search.
    case H2.
      case H3. apply IH1 to H5 H4. search.
      apply IH to H3 H4. search.
    case H2. apply IH to H3 H4. search.
    case H2. apply IH1 to H3 H4. search.
    case H2. apply IH to H3 H4. search.
  intros. case H1.
    case H2. search.
    case H2. apply IH to H3 H4. search.
  intros. case H1.
    case H2.
      apply IH to H3 H4. exists (t\ let E3 t). search.
      case H3. apply IH3 to H6 H4. apply IH4 to H5 H7.
