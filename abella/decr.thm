% vim: et

%%% SYNTAX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Kind val, expr  type.

Type lam        (val -> expr) -> val.
Type ret        val -> expr.
Type app        val -> val -> expr.
Type let        expr -> (val -> expr) -> expr.
Type shift0     ((expr -> expr) -> expr) -> expr.
%Type delim      val -> expr -> expr.
%Type ask        expr -> expr.
%Type hole       expr.

Define is_expr : expr -> prop,
       is_val : val -> prop,
       is_evctx : expr -> prop by
  nabla x, is_val x;
  is_val (lam E) := nabla x, is_expr (E x);

  is_expr (app V U) := is_val V /\ is_val U;
  is_expr (let E T) := is_expr E /\ nabla x, is_expr (T x);
%  is_expr (delim U E) := is_val U /\ is_expr E;
  is_expr (shift0 E) := nabla k, is_expr (E k);
  is_expr (ret V) := is_val V;
%  is_expr (ask (delim U E)) := is_val U /\ is_evctx E;
%  nabla k, is_expr (ask (k (E k))) := nabla k, is_evctx (E k);
  nabla k, is_expr (k (E k)) := nabla k, is_expr (E k).
%
%  is_evctx hole;
%  is_evctx (let E T) := is_evctx E /\ nabla x, is_expr (T x).

%%% NATURAL NUMBERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Author: Todd Wilson (https://abella-prover.org/examples/misc/well-founded.html)
%%

%%%% Natural numbers

Kind nat type.
Type z  nat.
Type s  nat -> nat.

% Ground nats
Define is_nat : nat -> prop by
  is_nat z;
  is_nat (s N) := is_nat N.

% Less than
Define lt : nat -> nat -> prop by
  lt N (s N);
  lt N1 (s N2) := lt N1 N2.

% The accessible part of the less-than relation
Define lt_acc : nat -> prop by
  lt_acc N := forall M, lt M N -> lt_acc M.


%%%% Every natural number is accessible.

Theorem nat_acc : forall N, is_nat N -> lt_acc N.
induction on 1. intros. case H1.
  unfold. intros. case H2.
  apply IH to H2. unfold. intros. case H4.
    search.
    case H3. apply H6 to H5. search.


%%%% Some properties of lt

Theorem lt_z : forall N, is_nat N -> lt z (s N).
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

Theorem lt_s : forall N1 N2, lt N1 N2 -> lt (s N1) (s N2).
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.


%%% LABELS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Kind lbl type.
Type e  nat -> lbl.
Type ne lbl.
%Type letv, dv, ds, ks, dls, ad, av lbl.
%Type lets, letlet nat -> lbl.

Define llt : lbl -> lbl -> prop by
%  llt (letlet N) (letlet M) := lt N M;
%  llt (letlet N) (lets M);
%  llt dls (lets M);
%  llt ad (lets M);
%  llt av (lets M);
%  llt (lets N) (lets M) := lt N M.
  llt ne (e N);
  llt (e N) (e M) := lt N M.

%%% PARALLEL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% "limit" approach
%Define par : nat -> nat -> expr -> expr -> prop,
%       parv : nat -> val -> val -> prop by
%
%  nabla x, parv M x x;
%  parv M (lam E) (lam E') := nabla x, par M M (E x) (E' x);
%
%  par M N (app (lam E) V) (E' V') := parv M V V' /\ nabla x, par M M (E x) (E' x);
%  par M N (let (ret V) E) (E' V') := parv M V V' /\ nabla x, par M M (E x) (E' x);
%  par M (s N) (let (shift0 E) T) (shift0 k\ E' (o\ k (let o T'))) :=
%    nabla x, par M M (T x) (T' x) /\ nabla k, par M M (E k) (E' k);
%
%  par M N (app V U) (app V' U') := parv M V V' /\ parv M U U';
%  par M z (let E T) (let E' T') := par M z E E' /\ nabla x, par M M (T x) (T' x);
%  par M (s N) (let E T) (let E' T') := par M N E E' /\ nabla x, par M M (T x) (T' x);
%  par M N (shift0 E) (shift0 E') := nabla k, par M M (E k) (E' k);
%  par M N (ret V) (ret V') := parv M V V';
%  nabla k, par M N (k (E k)) (k (E' k)) := nabla k, par M M (E k) (E' k).


Define letn : nat -> expr -> expr -> prop,
       letnv : nat -> val -> val -> prop,
       lete : nat -> nat -> expr -> expr -> prop by

  nabla x, letnv N x x;
  letnv N (lam E) (lam E') := nabla x, letn N (E x) (E' x);

  lete N (s M) (let (shift0 E) T) (shift0 k\ E' (o\ k (let o T'))) := nabla k x, letn N (E k) (E' k) /\ letn N (T x) (T' x);
%  lete N (s M) (let (let E T1) T2) (let E' x\ let (T1' x) T2') := nabla x, lete N z E E' /\ letn N (T1 x) (T1' x) /\ letn N (T2 x) (T2' x);
  lete N (s M) (let E T) (let E' T') := nabla x, lete N M E E' /\ letn N (T x) (T' x);
  lete N z (let E T) (let E' T') := nabla x, lete N z E E' /\ letn N (T x) (T' x);
  lete N M (app V U) (app V' U') := letnv N V V' /\ letnv N U U';
  lete N M (ret V) (ret V') := letnv N V V';
  lete N M (shift0 E) (shift0 E') := nabla k, letn N (E k) (E' k);
  nabla k, lete N M (k (E k)) (k (E' k)) := nabla k, letn N (E k) (E' k);

  letn N E E' := lete N N E E'.

Theorem letn_incrs :
  (forall N E E', letn N E E' -> letn (s N) E E') /\
  (forall N E E', letnv N E E' -> letnv (s N) E E') /\
  (forall N M E E', lete N M E E' -> lete (s N) (s M) E E') /\
  (forall N E E', lete N z E E' -> lete (s N) z E E').
  induction on 1 1 1 1. split.
  intros. case H1. apply IH2 to H2. search.
  intros. case H1.
    search.
    apply IH to H2. search.
  intros. case H1.
    apply IH to H2. apply IH to H3. search.
    apply IH2 to H2. apply IH to H3. search.
    apply IH3 to H2. apply IH to H3. search.
    apply IH1 to H2. apply IH1 to H3. search.
    apply IH1 to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.
  intros. case H1.
    apply IH3 to H2. apply IH to H3. search.
    apply IH1 to H2. apply IH1 to H3. search.
    apply IH1 to H2. search.
    apply IH to H2. search.
    apply IH to H2. search.

Theorem lete_incrr :
  (forall N M E E', lete N M E E' -> lete N (s M) E E').
  induction on 1.
  intros. case H1.
    search.
    apply IH to H2. search.
    search.
    search.
    search.
    search.
    search.

Split letn_incrs as letn_incr, letnv_incr, lete_incr, letez_incr.

Theorem letn_sublet :
  forall N T T', (nabla x, letn N (T x) (T' x)) ->
  (forall E E', nabla (k : expr -> expr), letn N (E k) (E' k) -> letn (s N) (E (o\ k (let o T))) (E (o\ k (let o T')))) /\
  (forall E E', nabla (k : expr -> expr), letnv N (E k) (E' k) -> letnv (s N) (E (o\ k (let o T))) (E (o\ k (let o T')))) /\
  (forall M E E', nabla (k : expr -> expr), lete N M (E k) (E' k) -> lete (s N) M (E (o\ k (let o T))) (E (o\ k (let o T')))) /\
  (forall E E', nabla (k : expr -> expr), lete N z (E k) (E' k) -> lete (s N) z (E (o\ k (let o T))) (E (o\ k (let o T')))).
  intros. induction on 1 1 1 1. split.
  intros. case H2. apply IH2 to H3. apply lete_incrr to H4. search.
  intros. case H2.
    search.
    apply IH to H3. search.
  intros. case H2.
    apply IH to H3. apply IH to H4. search.
    apply IH2 to H3. apply IH to H4. search.
    apply IH3 to H3. apply IH to H4. search.
    apply IH1 to H3. apply IH1 to H4. search.
    apply IH1 to H3. search.
    apply IH to H3. search.
    apply IH to H3. search.
    case H3. apply IH2 to H4. case H1. apply letn_incr to H6. search.
  intros. case H2.
    apply IH3 to H3. apply IH to H4. search.
    apply IH1 to H3. apply IH1 to H4. search.
    apply IH1 to H3. search.
    apply IH to H3. search.
    apply IH to H3. search.
    case H1. case H3. apply IH2 to H5. apply letn_incr to H4. search.


Theorem letn_decr :
  (forall N E E1 E2, letn N E E1 -> letn N E E2 -> exists E3, letn N E1 E3 /\ letn N E2 E3) /\
  (forall N E E1 E2, letnv N E E1 -> letnv N E E2 -> exists E3, letnv N E1 E3 /\ letnv N E2 E3) /\
  (forall N E E1 E2, lete N N E E1 -> lete N N E E2 -> exists E3, lete N N E1 E3 /\ lete N N E2 E3).
  induction on 1 1 1. split.
  intros. case H1. case H2. apply IH2 to H3 H4. search.
  intros. case H1.
    case H2. search.
    case H2. apply IH to H3 H4. search.
  intros. case H1.
    case H2.
Quit.


%% "maximum" approach
%Define par : nat -> expr -> expr -> prop,
%       parv : nat -> val -> val -> prop by
%
%  nabla x, parv M x x;
%  parv M (lam E) (lam E') := nabla x, par M (E x) (E' x);
%
%  par M (app (lam E) V) (E' V') := parv M V V' /\ nabla x, par M (E x) (E' x);
%  par M (let (ret V) E) (E' V') := parv M V V' /\ nabla x, par M (E x) (E' x);
%  par MAX (let (shift0 E) T) (shift0 k\ E' (o\ k (let o T'))) :=
%    nabla x, par N (T x) (T' x) /\ nabla k, par M (E k) (E' k) /\
%    max3 (s z) N M MAX;
%
%  par MAX (app V U) (app V' U') := parv M V V' /\ parv N U U' /\ max M N MAX;
%  par M (let E T) (let E' T') := par M z E E' /\ nabla x, par M (T x) (T' x);
%  par MAX (let E T) (let E' T') := par (s N) E E' /\ nabla x, par M (T x) (T' x) /\ max (s (s N)) M MAX;
%  par M (shift0 E) (shift0 E') := nabla k, par M (E k) (E' k);
%  par M (ret V) (ret V') := parv M V V';
%  nabla k, par M (k (E k)) (k (E' k)) := nabla k, par M (E k) (E' k).

