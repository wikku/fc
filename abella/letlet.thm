% vim: et



%%% SYNTAX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Kind val, expr  type.

Type lam        (val -> expr) -> val.
Type ret        val -> expr.
Type app        val -> val -> expr.
Type let        expr -> (val -> expr) -> expr.

Define is_expr : expr -> prop,
       is_val : val -> prop by
  nabla x, is_val x;
  is_val (lam E) := nabla x, is_expr (E x);

  is_expr (app V U) := is_val V /\ is_val U;
  is_expr (let E T) := is_expr E /\ nabla x, is_expr (T x);
  is_expr (ret V) := is_val V.

%%% NATURAL NUMBERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Author: Todd Wilson (https://abella-prover.org/examples/misc/well-founded.html)
%%

%%%% Natural numbers

Kind nat type.
Type z  nat.
Type s  nat -> nat.

% Ground nats
Define is_nat : nat -> prop by
  is_nat z;
  is_nat (s N) := is_nat N.

% Less than
Define lt : nat -> nat -> prop by
  lt N (s N);
  lt N1 (s N2) := lt N1 N2.

% The accessible part of the less-than relation
Define lt_acc : nat -> prop by
  lt_acc N := forall M, lt M N -> lt_acc M.


%%%% Every natural number is accessible.

Theorem nat_acc : forall N, is_nat N -> lt_acc N.
induction on 1. intros. case H1.
  unfold. intros. case H2.
  apply IH to H2. unfold. intros. case H4.
    search.
    case H3. apply H6 to H5. search.


%%%% Some properties of lt

Theorem lt_z : forall N, is_nat N -> lt z (s N).
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.

Theorem lt_s : forall N1 N2, lt N1 N2 -> lt (s N1) (s N2).
induction on 1. intros. case H1.
  search.
  apply IH to H2. search.


%%% LABELS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Kind lbl type.
Type e  nat -> lbl.
Type ne lbl.
%Type letv, dv, ds, ks, dls, ad, av lbl.
%Type lets, letlet nat -> lbl.

Define llt : lbl -> lbl -> prop by
%  llt (letlet N) (letlet M) := lt N M;
%  llt (letlet N) (lets M);
%  llt dls (lets M);
%  llt ad (lets M);
%  llt av (lets M);
%  llt (lets N) (lets M) := lt N M.
  llt ne (e N);
  llt (e N) (e M) := lt N M.

%%% PARALLEL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Kind mode type.
Type g, nll mode.

Define md : mode -> prop by md g; md nll.

Define par : mode -> expr -> expr -> prop,
       parv : val -> val -> prop by

  nabla x, parv x x;
  parv (lam E) (lam E') := nabla x, par g (E x) (E' x);

  par g (let (let E T1) T2) (let E' T') := par nll E E' /\ nabla x, par g (let (T1 x) T2) (T' x);

  par M (app V U) (app V' U') := parv V V' /\ parv U U';
  par M (let E T) (let E' T') := par M E E' /\ nabla x, par g (T x) (T' x);
  par M (ret V) (ret V') := parv V V'.

Theorem par_subvs :
  forall U U', parv U U' ->
  (forall M E E', nabla x, par M (E x) (E' x) -> par M (E U) (E' U')) /\
  (forall E E', nabla x, parv (E x) (E' x) -> parv (E U) (E' U')).
  intros. induction on 1 1. split.
  intros. case H2.
    apply IH to H3. apply IH to H4. search.
    apply IH1 to H3. apply IH1 to H4. search.
    apply IH to H3. apply IH to H4. search.
    apply IH1 to H3. search.
  intros. case H2.
    search.
    search.
    apply IH to H3. search.

Theorem nll_g : forall E E', par nll E E' -> par g E E'.
  induction on 1.
  intros. case H1.
    search.
    apply IH to H2. search.
    search.

Split par_subvs as par_subv, parv_subv.

Theorem diam_md :
  forall M E2 E3, md M -> (exists E4, par nll E2 E4 /\ par nll E3 E4) -> (exists E4, par M E2 E4 /\ par M E3 E4).
  intros. case H1.
    case H2. apply nll_g to H3. apply nll_g to H4. search.
    search.

Theorem par_diams :
  (forall M E E1 E2, par M E E1 -> par M E E2 -> md M -> exists E3, par M E1 E3 /\ par M E2 E3) /\
  (forall E E1 E2, parv E E1 -> parv E E2 -> exists E3, parv E1 E3 /\ parv E2 E3).
  induction on 1 1. split.
  intros. case H1.
    case H2.
      apply IH to H4 H6 _. apply IH to H5 H7 _. backchain diam_md.
      case H6.
        case H4. apply IH to *H10 *H8 _. case H9.
          
