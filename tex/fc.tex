\documentclass[a4paper, 11pt,titlepage, openright, twoside]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{silence}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage[inline]{enumitem}
\usepackage{newunicodechar}
\usepackage[margin=3cm,bindingoffset=1cm]{geometry}
\usepackage{stmaryrd}
\SetSymbolFont{stmry}{bold}{U}{stmry}{m}{n}
% https://tex.stackexchange.com/a/106719
\DeclareSymbolFont{sfletters}{OML}{cmbrm}{m}{it}
\usepackage[nopatch=footnote]{microtype}
\usepackage[dvipsnames]{xcolor}
\usepackage{mathpartir}
\usepackage{biblatex}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{tikz}
\usepackage{listings}
\lstset{basicstyle= \footnotesize \ttfamily}
\lstset{language=ml}

\usepackage[nodisplayskipstretch]{setspace}
\setlength{\parskip}{0pt}

\addbibresource{refs.bib}


\title{\textbf{A Fine Calculus for Static Delimited Control}}
\author{Wiktor Kuchta}

\date{60 września 2024} %TODO

\usepackage{titling}

\renewcommand \maketitlehookb {
  \begin{center}\large
  Fajny rachunek dla statycznie ograniczonych operatorów sterowania
  \end{center}
  \vfil
}

\renewcommand \maketitlehookc {
  \vfil
  \begin{center}
  \large Praca magisterska \\[0.85em]
  \begin{tabular}[t]{rl}
  \textbf{Promotor:} & dr hab. Dariusz Biernacki
  \end{tabular}\end{center}
  \vfil\vfil\vfil\vfil
  \begin{center}Uniwersytet Wroc\l{}awski\\
  Wydzia\l{} Matematyki i Informatyki\\
  Instytut Informatyki
  \end{center}
}


\newcommand{\keyword}[1]{\textsf{\textup{#1}}}
\newcommand{\KwDo}{\keyword{do}}
\newcommand{\Do}{\KwDo\;}
\newcommand{\KwHandle}{\keyword{handle}}
\newcommand{\Handle}{\KwHandle\;}
\newcommand{\KwLet}{\keyword{let}}
\newcommand{\Let}[3]{\keyword{let}\;#1=#2\;\keyword{in}\;#3}
\newcommand{\Lift}[1]{\boldsymbol{[}#1\boldsymbol{]}}
\newcommand{\subst}[2]{\{#1{:=}#2\}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\K}{\mathcal{K}}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\kT}{\mathsf{T}}
\newcommand{\kE}{\mathsf{E}}
\newcommand{\kR}{\mathsf{R}}
\newcommand{\Free}{\textrm{-}\mathrm{free}}
\newcommand{\Obs}{\mathrm{Obs}}
\newcommand{\N}{\mathbb{N}}
\DeclareMathOperator{\dom}{dom}
\newcommand{\+}{\enspace}

\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}


\newunicodechar{│}{\mid} % Digr vv
\newunicodechar{╱}{\mathbin{/}} % Digr FD
\newunicodechar{∷}{::} % Digr ::
\newunicodechar{□}{\square} % Digr OS
\newunicodechar{∅}{\emptyset} % Digr /0
\newunicodechar{α}{\alpha}
\newunicodechar{β}{\beta}
\newunicodechar{δ}{\delta} % Digr d*
\newunicodechar{ε}{\varepsilon}
\newunicodechar{γ}{\gamma} % Digr g*
\newunicodechar{ι}{\iota} % Digr i*
\newunicodechar{κ}{\kappa}
\newunicodechar{λ}{\lambda}
\newunicodechar{μ}{\mu}
\newunicodechar{ν}{\nu}
\newunicodechar{ρ}{\rho}
\newunicodechar{σ}{\sigma}
\newunicodechar{τ}{\tau}
\newunicodechar{η}{\eta} % Digr y*
\newunicodechar{Δ}{\Delta}
\newunicodechar{Γ}{\Gamma}
\newunicodechar{Ω}{\Omega} % digr W*
\newunicodechar{ℕ}{\N} % Digr NN 8469 nonstandard
\newunicodechar{⊆}{\subseteq} % Digr (_
\newunicodechar{∪}{\cup} % Digr )U
\newunicodechar{∈}{\in} % Digr (-
\newunicodechar{∃}{\exists} % Digr TE
\newunicodechar{∀}{\forall} % Digr FA
\newunicodechar{∧}{\wedge} % Digr AN
\newunicodechar{∨}{\vee} % Digr OR
\newunicodechar{⊥}{\bot} % Digr -T
\newunicodechar{⊢}{\vdash} % Digr \- 8866 nonstandard
\newunicodechar{⊨}{\models} % Digr \= 8872 nonstandard
\newunicodechar{⊤}{\top} % Digr TO 8868 nonstandard
\newunicodechar{⇒}{\implies} % Digr =>
\newunicodechar{⇔}{\iff} % Digr ==
\newunicodechar{↦}{\mapsto} % Digr T> 8614 nonstandard
\newunicodechar{≠}{\neq}
\newunicodechar{⟦}{\llbracket} % Digr [[ 10214 nonstandard (needs pkg stmaryrd)
\newunicodechar{⟧}{\rrbracket} % Digr ]] 10215 nonstandard
\newunicodechar{≥}{\ge}
\newunicodechar{≤}{\le}


% cursed
\WarningFilter{newunicodechar}{Redefining Unicode}
\newunicodechar{·}{\ifmmode\cdot\else\textperiodcentered\fi} % Digr .M
\newunicodechar{×}{\ifmmode\times\else\texttimes\fi} % Digr *X
\newunicodechar{→}{\ifmmode\rightarrow\else\textrightarrow\fi} % Digr ->
\newunicodechar{←}{\ifmmode\leftarrow\else\textleftarrow\fi} % Digr <-
\newunicodechar{…}{\ifmmode\dots\else\textellipsis\fi} % Digr .,
\newunicodechar{⟨}{\langle}
\newunicodechar{⟩}{\rangle}

\begin{document}

\maketitle


\thispagestyle{empty}
\cleardoublepage
\begin{abstract}
	We consider a variant of the call-by-value $λμ$-calculus extended with control delimiters,
	in which $μ$ becomes the static delimited control operator shift0.
	We propose new reduction rules allowed by static delimited control.
	We let delimiters carry data (resulting in a form of dynamic binding), which lets us express algebraic effects and handlers as well as exceptions.
	We propose purity assertions for lightweight purity-based reasoning.
	We prove the reduction is confluent and adequate wrt.\ operational semantics.
	The calculus is stronger than previous results in the literature and could form basis for
	reasoning and optimizations for all the aforementioned forms of control.
	\begin{center} \rule[3pt]{300pt}{1pt} \end{center}
	polski
\end{abstract}


\thispagestyle{empty}
\cleardoublepage
\setcounter{page}{5}
\tableofcontents


\chapter{A gentle introduction}

\chapter{Confluence}

We first prove that structural reduction
$$\xrightarrow{Str} \;=\; \xrightarrow{let.\S} ∪ \xrightarrow{d.\S} ∪ \xrightarrow{k.\S}$$
is strongly normalizing. We adapt the approach of de Groote\cite{Groote}.

Define the norm $|·|$ as follows:
\begin{align*}
	|x| &= 1 \\
	|λx. e| &= |e| \\
	|\S κ. e| &= |e| \\
	|v\;u| &= |v| + |u| \\
	|\Let{x}{e}{t}| &= |e| + \# e ·|t| \\
	|⟨e⟩| &= |e| + \# e \\
	|κ[e]| &= |e| + \# e
\end{align*}
and the ``substitution point count'' $\#$ and ``continuation variable count'' $\#_κ$ as follows:%
\footnote{
	These are upper bounds, the names are meant to convey intuition and are not fully accurate.
}%
\begin{align*}
%	\# x &= 1 \\
%	\# λx. e &= 1 \\
	\# v &= 1 \\
	\# \S κ.\,e &= 1 + \# e + \#_κ e \\
	\# v\;u &= 1 \\
	\# \Let{x}{e}{t} &= \# e \\
	\# ⟨e⟩ &= \# e \\
	\# κ[e] &= \# e
\end{align*}

\begin{align*}
	\#_κ x &= 0 \\
	\#_κ λx. e &= \#_κ e \\
	\#_κ \S κ'.\,e &= \#_κ e \\
	\#_κ v\;u &= \#_κ v + \#_κ u \\
	\#_κ \Let{x}{e}{t} &= \#_κ e + \# e · \#_κ t \\
	\#_κ ⟨e⟩ &= \#_κ e \\
	\#_κ κ[e] &= \#_κ e + \# e \\
	\#_κ κ'[e] &= \#_κ e
\end{align*}

\begin{prop}
	If $κ$ doesn't occur in $e$, then $\#_κ e = 0$.
\end{prop}

\begin{lemma}
	\item
	\begin{enumerate}[label=(\roman*),ref=\thelemma (\roman*)]
		\item $\# e\subst{κ'}{κ'[\Let{x}{□}{t}]} = \# e$
		\item $\#_κ e\subst{κ'}{κ'[\Let{x}{□}{t}]} = \#_κ e + \#_{κ'} e · \#_κ t$
	\end{enumerate}
\end{lemma}
\begin{proof}
	Induction on $e$. Let $K$ stand for $κ'[\Let{x}{□}{t}]$.
	\begin{enumerate}[label=(\roman*),ref=\thelemma (\roman*)]
		\item
			\begin{enumerate}
				\item $\# v\subst{κ'}{K} = 1 = \# v$
				\item $\# \S κ.\,e\subst{κ'}{K}
					= 1 + \# e\subst{κ'}{K} + \#_κ e\subst{κ'}{K}
					\stackrel{\text{IH}}{=} 1 + \# e + (\#_κ e + \#_{κ'} e · \#_κ t)
					= 1 + \# e + (\#_κ e + \#_{κ'} e · 0)
					= \# \S κ.\,e$
				\item $\# v\subst{κ'}{K}\;u\subst{κ'}{K} = 1 = \# v\;u$
				\item $\# \Let{x}{e\subst{κ'}{K}}{t'\subst{κ'}{K}} = \# e\subst{κ'}{K} \stackrel{\text{IH}}{=} \# e = \# \Let{x}{e}{t'}$
				\item $\# ⟨e\subst{κ'}{K}⟩ = \# e\subst{κ'}{K} \stackrel{\text{IH}}{=} \# e = \# ⟨e⟩$
				\item $\# (κ'[e])\subst{κ'}{K} = \# κ'[\Let{x}{e\subst{κ'}{K}}{t}] = \# e\subst{κ'}{K} \stackrel{\text{IH}}{=} \# e = \# κ'[e]$
				\item ($κ≠κ'$) $\# (κ[e])\subst{κ'}{K} = \# κ[e\subst{κ'}{K}] = \# e\subst{κ'}{K} \stackrel{\text{IH}}{=} \# e = \# κ[e]$
			\end{enumerate}
		\item
			\begin{enumerate}
				\item $\#_κ x\subst{κ'}{K} = \#_κ x = 0 = \#_κ x + \#_{κ'} x · \#_κ t$
				\item $\#_κ λx.\,e\subst{κ'}{K} = \#_κ e\subst{κ'}{K} \stackrel{\text{IH}}{=}
					\#_κ e + \#_{κ'} e · \#_κ t = \#_κ λx.\,e + \#_{κ'} λx.\,e · \#_κ t$
				\item $\#_κ v\subst{κ'}{K}\;u\subst{κ'}{K} \stackrel{\text{IH}}{=} \#_κ v + \#_{κ'} v · \#_κ t + \#_κ u + \#_{κ'} u · \#_κ t
					= (\#_κ v + \#_κ u) + (\#_{κ'} v + \#_{κ'} u) · \#_κ t = \#_κ (v\; u) + \#_{κ'} (v\;u) · \#_κ t$
				\item $\#_κ \Let{y}{e\subst{κ'}{K}}{t'\subst{κ'}{K}} = \#_κ e\subst{κ'}{K} + \# e\subst{κ'}{K} · \#_κ t'\subst{κ'}{K}
					\stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t + \# e · (\#_κ t' + \#_{κ'} t' · \#_κ t)
					= \#_κ e + \# e · \#_κ t' + (\#_{κ'} e + \# e · \#_{κ'} t') · \#_{κ} t
					= \#_κ \Let{y}{e}{t'} + \#_{κ'} \Let{y}{e}{t'} · \#_κ t$
				\item $\#_κ ⟨e\subst{κ'}{K}⟩ = \#_κ e\subst{κ'}{K} \stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t
					= \#_κ ⟨e⟩ + \#_{κ'} ⟨e⟩ + \#_κ t$
				\item ($κ≠κ'$) $\#_κ (κ'[e])\subst{κ'}{K} = \#_κ κ'[\Let{x}{e\subst{κ'}{K}}{t}] = \#_κ \Let{x}{e\subst{κ'}{K}}{t}
					= \#_κ e\subst{κ'}{K} + \# e\subst{κ'}{K} · \#_κ t
					\stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t + \# e · \#_κ t
					= \#_κ e + \#_{κ'} e · \#_κ t + \# e · \#_κ t = \#_κ κ'[e] + \#_{κ'} κ'[e] · \#_κ t$
				\item ($κ≠κ''≠κ'$) $\#_κ (κ''[e])\subst{κ'}{K} = \#_κ κ''[e\subst{κ'}{K}] = \#_κ e\subst{κ'}{K}
					\stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t
					= \#_κ κ''[e] + \#_{κ'} κ''[e] · \#_κ t$
				\item ($κ≠κ'$) $\#_κ (κ[e])\subst{κ'}{K} = \#_κ κ[e\subst{κ'}{K}]
					= \#_κ e\subst{κ'}{K} + \# e\subst{κ'}{K}
					\stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t + \# e
					= \#_κ κ[e] + \#_{κ'} κ[e] · \#_κ t$
				\item ($κ = κ'$) $\#_{κ'} (κ'[e])\subst{κ'}{K} = \#_{κ'} κ'[\Let{x}{e\subst{κ'}{K}}{t}]
					= \#_{κ'} \Let{x}{e\subst{κ'}{K}}{t} + \# \Let{x}{e\subst{κ'}{K}}{t}
					= \#_{κ'} e\subst{κ'}{K} + \# e\subst{κ'}{K} · \#_{κ'} t + \# e\subst{κ'}{K}
					\stackrel{\text{IH}}{=} \#_{κ'} e + \#_{κ'} e · \#_{κ'} t + \# e · \#_{κ'} t + \# e
					= \#_{κ'} κ'[e] + \#_{κ'} κ'[e] · \#_{κ'} t $
			\end{enumerate}
	\end{enumerate}
\end{proof}

\begin{lemma}
	If $e \xrightarrow{Str} e'$, then
	\begin{enumerate*}[label=(\roman*),ref=\thelemma (\roman*)]
		\item $\#e ≥ \#e'$ and \label{str_cnt}
		\item $\#_κ e ≥ \#_κ e'$.
	\end{enumerate*}
\end{lemma}
\begin{proof}
	We check reductions at the root of the term, other cases follow by induction.
	\begin{enumerate}
		\item $\Let{x}{\S κ.\,e}{t} → \S κ.\,e\subst{κ}{κ[\Let{x}{□}{t}]}$ \\
		      $\#\Let{x}{\S κ.\,e}{t}
			  = 1 + \# e + \#_κ e
			  = 1 + \# e + \#_{κ} e + \#_{κ} e · \#_{κ} t
			  = 1 + \# e\subst{κ}{κ[\Let{x}{□}{t}]} + \#_{κ} e\subst{κ}{κ[\Let{x}{□}{t}]}
			  = \# \S κ.\,e\subst{κ}{κ[\Let{x}{□}{t}]}$ \\
			  $\#_κ \Let{x}{\S κ'.\,e}{t} = \#_κ e + (1 + \# e + \#_{κ'} e) · \#_κ t
			  > \#_κ e + \#_{κ'} e · \#_κ t
			  = \#_κ e\subst{κ'}{κ'[\Let{x}{□}{t}]}
			  = \#_κ \S κ'.\,e\subst{κ'}{κ'[\Let{x}{□}{t}]}$
		\item $⟨\S κ.\,e⟩ → e\subst{κ}{⟨□⟩}$ \\
		      $\#⟨\S κ.\,e⟩ = 1 + \# e + \#_κ e$ \\
			  $\#e\subst{κ}{⟨□⟩} = $
		\item $κ'[\S κ.\,e] → e\subst{κ}{κ'}$
		      $\#κ'[\S κ.\,e] = 1 + \# e + \#_κ e$ \\
			  $\#e\subst{κ}{κ'} = $
	\end{enumerate}
\end{proof}

\begin{lemma}
	$|e\subst{κ}{κ[\Let{x}{□}{t}]}| = |e| + \#_κ e · |t|$
\end{lemma}
\begin{proof}
	\item
	\begin{enumerate}
		\item $|(κ[e])\subst{κ}{κ[\Let{x}{□}{t}]}| = |κ[\Let{x}{e\subst{κ}{κ[\Let{x}{□}{t}]}}{t}]|
			= |e\subst{κ}{κ[\Let{x}{□}{t}}| + \# e\subst{κ}{κ[\Let{x}{□}{t}} · |t|
			\stackrel{\text{IH}}{=} |e| + \#_κ e · |t| + \# e · |t| = |e| + \#_κ κ[e] · |t| ≠ |κ[e]| + \#_κ κ[e] · |t|$
			wrong!

		\item ($κ' ≠ κ$) $|(κ'[e])\subst{κ}{κ[\Let{x}{□}{t}]}| = |κ'[e\subst{κ}{κ[\Let{x}{□}{t}]}]| =
 |e\subst{κ}{κ[\Let{x}{□}{t}]}]| + \# e\subst{κ}{κ[\Let{x}{□}{t}]}$

	\end{enumerate}
\end{proof}

\begin{theorem}
	If $e \xrightarrow{Str} e'$, then $|e| > |e'|$.
\end{theorem}
\begin{proof}
	We check reductions at the root of the term, other cases follow by induction and Lemma \ref{str_cnt}.
	\begin{enumerate}
		\item $\Let{x}{\S κ.\,e}{t} → \S κ.\,e\subst{κ}{κ[\Let{x}{□}{t}]}$ \\
		      $|\Let{x}{\S κ.\,e}{t}| = |e| + \# (\S κ.\, e) · |t| = |e| + (1 + \# e + \#_κ e) · |t|$ \\
			  $|e\subst{κ}{κ[\Let{x}{□}{t}]}|=|\S κ.\,e\subst{κ}{κ[\Let{x}{□}{t}]}|$
		\item $⟨\S κ.\,e⟩ → e\subst{κ}{⟨□⟩}$
		      $|⟨\S κ.\,e⟩ → e\subst{κ}{⟨□⟩}$
		\item $κ'[\S κ.\,e] → e\subst{κ}{κ'}$
	\end{enumerate}
\end{proof}
\begin{corollary}
	$\xrightarrow{Str}$ is strongly normalizing.
\end{corollary}


\chapter{Adequacy}

\begin{theorem}[Standardization]
\end{theorem}
\begin{corollary} If $e →^* v$, then $e ↦^* v' →_i^* v$.
\end{corollary}
\begin{proof}
	By standardization and since $→_i$ can't turn a nonvalue into a value.
\end{proof}


\begin{theorem}
	If $e → e'$, then $e$ evals to a value iff $e'$ evals to a value.
\end{theorem}
\begin{proof}
%	We take the proof from Crary.

	If $e' ↦^* v$, then $e →^* v$. By corollary to stan we have $e ↦^* v' →_i^* v$.

	If $e ↦^* v$, then by confluence we have $v →^* v' ←^* e'$, where $v'$ must be a value
	because $→$ preserves valueness. By corollary to stan we have $e' ↦^* v'' →_i^* v'$.

\end{proof}

\begin{prop}[Stuck terms]
\end{prop}

\chapter{Abella mechanization}

\chapter{Related work}


\section*{Distributing delimiters}
There is a strand of work which tackles static delimited control from the opposite direction.
Whereas we use structural reduction so that S moves closer to the delimiter, that strand's defining feature is
the delimiter distributing over let expressions so that \textit{a} delimiter can meet the control operator:

There, the return clause is an integral part of the syntax. On a sequence of lets this becomes

We consider turning every let into a delimiter unsatisfactory, since delimiters usually have a much higher runtime cost than let bindings.

Because they lack structural reduction, those systems cannot perform the optimizations in examples TODO.
We show that translations from those calculi preserve equations (understood as the equivalence closure of reduction)
to argue that our calculus is more powerful.

\section*{shift0 calculus}
By reflection\cite{ppdp21} it follows that the original shift0 equational theory by Materzok is also less powerful,
but for completeness we show it directly.

\section*{Delimited $λμ$}

\section*{Confluence}

\section*{Tail reductions and letcc}

\chapter{Discussion and future work}

While this work brings forth many new ideas, it is far from being the IR of a compiler.

We believe all results transfer to multi-prompt delimited control, where we have independent sets of labeled operators $S^\ell κ. e$, $⟨e⟩^\ell$.
This is necessary for working with multiple effects, though the lift construct can to some extent simulate that.
Naturally, the purity assertions also could be refined to block or allow specific listed effects.

Realistic languages also have more tail contexts such as $if b then □ else □$ as well as evaluation contexts.

join points?





\hfuzz=1pt
\printbibliography[heading=bibintoc]

\end{document}
