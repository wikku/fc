\documentclass[a4paper, 11pt,titlepage, openright, twoside]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{silence}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage[inline]{enumitem}
\usepackage{newunicodechar}
\usepackage[margin=3cm,bindingoffset=1cm]{geometry}
\usepackage{stmaryrd}
\SetSymbolFont{stmry}{bold}{U}{stmry}{m}{n}
% https://tex.stackexchange.com/a/106719
\DeclareSymbolFont{sfletters}{OML}{cmbrm}{m}{it}
\usepackage[nopatch=footnote]{microtype}
\usepackage[dvipsnames]{xcolor}
\usepackage{mathpartir}
\usepackage{biblatex}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{listings}
\lstset{basicstyle= \footnotesize \ttfamily}
\lstset{language=ml}

\usepackage[nodisplayskipstretch]{setspace}
\setlength{\parskip}{0pt}

\addbibresource{refs.bib}


\title{\textbf{A Fine Calculus for Static Delimited Control}}
\author{Wiktor Kuchta}

\date{60 września 2024} %TODO

\usepackage{titling}

\renewcommand \maketitlehookb {
  \begin{center}\large
  Fajny rachunek dla statycznie ograniczonych operatorów sterowania
  \end{center}
  \vfil
}

\renewcommand \maketitlehookc {
  \vfil
  \begin{center}
  \large Praca magisterska \\[0.85em]
  \begin{tabular}[t]{rl}
  \textbf{Promotor:} & dr hab. Dariusz Biernacki
  \end{tabular}\end{center}
  \vfil\vfil\vfil\vfil
  \begin{center}Uniwersytet Wroc\l{}awski\\
  Wydzia\l{} Matematyki i Informatyki\\
  Instytut Informatyki
  \end{center}
}


\newcommand{\shiftz}{\textsf{shift0}}
\newcommand{\abort}{\textsf{abort}}
\newcommand{\keyword}[1]{\textsf{\textup{#1}}}
\newcommand{\KwOp}{\keyword{op}}
\newcommand{\Op}{\KwOp\,}
\newcommand{\KwHandle}{\keyword{handle}}
\newcommand{\Handle}{\KwHandle\;}
\newcommand{\KwWith}{\keyword{with}}
\newcommand{\With}{\;\KwWith\;}
\newcommand{\KwRaise}{\keyword{raise}}
\newcommand{\Raise}{\KwRaise\;}
\newcommand{\Ask}{\textsf{ask}}
\newcommand{\KwTry}{\keyword{try}}
\newcommand{\Try}{\KwTry\;}
\newcommand{\KwLet}{\keyword{let}}
\newcommand{\Let}[3]{\keyword{let}\;#1\;\keyword{=}\;#2\;\keyword{in}\;#3}
\newcommand{\RLet}[3]{\Let{#1}{\raisebox{0.5 ex}{$#2$}}{#3}}
\newcommand{\KwLift}{\keyword{lift}}
\newcommand{\Lift}[1]{\KwLift\;#1}
\newcommand{\subst}[2]{\{#1{:=}#2\}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\K}{\mathcal{K}}
\renewcommand{\S}{\mathcal{S}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\kT}{\mathsf{T}}
\newcommand{\kE}{\mathsf{E}}
\newcommand{\kR}{\mathsf{R}}
\newcommand{\Free}{\textrm{-}\mathrm{free}}
\newcommand{\Obs}{\mathrm{Obs}}
\newcommand{\N}{\mathbb{N}}
\DeclareMathOperator{\dom}{dom}
\newcommand{\+}{\enspace}
\newcommand{\lStr}{\textsf{Str}}
\newcommand{\lPar}{\textsf{Par}}

\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{prop}{Proposition}


\newunicodechar{│}{\mid} % Digr vv
\newunicodechar{╱}{\mathbin{/}} % Digr FD
\newunicodechar{∷}{::} % Digr ::
\newunicodechar{□}{\square} % Digr OS
\newunicodechar{∅}{\emptyset} % Digr /0
\newunicodechar{α}{\alpha}
\newunicodechar{β}{\beta}
\newunicodechar{δ}{\delta} % Digr d*
\newunicodechar{ε}{\varepsilon}
\newunicodechar{γ}{\gamma} % Digr g*
\newunicodechar{ι}{\iota} % Digr i*
\newunicodechar{κ}{\kappa}
\newunicodechar{λ}{\lambda}
\newunicodechar{μ}{\mu}
\newunicodechar{ν}{\nu}
\newunicodechar{ρ}{\rho}
\newunicodechar{σ}{\sigma}
\newunicodechar{τ}{\tau}
\newunicodechar{η}{\eta} % Digr y*
\newunicodechar{Δ}{\Delta}
\newunicodechar{Γ}{\Gamma}
\newunicodechar{Ω}{\Omega} % digr W*
\newunicodechar{ℕ}{\N} % Digr NN 8469 nonstandard
\newunicodechar{⊆}{\subseteq} % Digr (_
\newunicodechar{∪}{\cup} % Digr )U
\newunicodechar{∈}{\in} % Digr (-
\newunicodechar{∃}{\exists} % Digr TE
\newunicodechar{∀}{\forall} % Digr FA
\newunicodechar{∧}{\wedge} % Digr AN
\newunicodechar{∨}{\vee} % Digr OR
\newunicodechar{⊥}{\bot} % Digr -T
\newunicodechar{⊢}{\vdash} % Digr \- 8866 nonstandard
\newunicodechar{⊨}{\models} % Digr \= 8872 nonstandard
\newunicodechar{⊤}{\top} % Digr TO 8868 nonstandard
\newunicodechar{⇒}{\implies} % Digr =>
\newunicodechar{⇔}{\iff} % Digr ==
\newunicodechar{↦}{\mapsto} % Digr T> 8614 nonstandard
\newunicodechar{≠}{\neq}
\newunicodechar{⟦}{\llbracket} % Digr [[ 10214 nonstandard (needs pkg stmaryrd)
\newunicodechar{⟧}{\rrbracket} % Digr ]] 10215 nonstandard
\newunicodechar{≥}{\ge}
\newunicodechar{≤}{\le}
\newunicodechar{≡}{\equiv}
\newunicodechar{≈}{\approx}


% cursed
\WarningFilter{newunicodechar}{Redefining Unicode}
\newunicodechar{·}{\ifmmode\cdot\else\textperiodcentered\fi} % Digr .M
\newunicodechar{×}{\ifmmode\times\else\texttimes\fi} % Digr *X
\newunicodechar{→}{\ifmmode\rightarrow\else\textrightarrow\fi} % Digr ->
\newunicodechar{←}{\ifmmode\leftarrow\else\textleftarrow\fi} % Digr <-
\newunicodechar{…}{\ifmmode\dots\else\textellipsis\fi} % Digr .,
\newunicodechar{⟨}{\langle}
\newunicodechar{⟩}{\rangle}

\begin{document}

\maketitle


\thispagestyle{empty}
\cleardoublepage
\begin{abstract}
	We consider a variant of the call-by-value $λμ$-calculus extended with control delimiters,
	in which $μ$ becomes the static delimited control operator shift0.
	We propose new reduction rules for cases where the captured continuation can be determined statically.
	We prove the calculus confluent and adequate wrt.\,operational semantics.
	We then let delimiters carry data (resulting in a form of dynamic binding), which lets us express deep effect handlers.
	The new reductions cooperate with the encoding to let us statically handle effects.
	We also propose natural encodings of return clauses for delimiters.
%	We propose purity assertions for lightweight purity-based reasoning.
%	We prove the reduction is confluent and adequate wrt.\ operational semantics.
	We argue that the calculus is stronger than previous results in the literature and could form basis for
	reasoning and optimizations for the aforementioned forms of control.
	\begin{center} \rule[3pt]{300pt}{1pt} \end{center}
	polski
\end{abstract}


\thispagestyle{empty}
\cleardoublepage
\setcounter{page}{5}
\tableofcontents


\chapter{Introduction}
Consider a program of the following form in a language with (unnamed) exceptions:
\begin{align*}
	&\Try \\
	&\quad \Let{x}{e}{\Raise (x*2)} \\
	&\KwWith\; z.\,z*3
\end{align*}
If the execution gets to $\Raise (x*2)$, the handler will catch the exception and produce the result $x*2*3$.
%$$\Try \Let{x}{e}{\Raise (2*x)} \With z.\,3 * z$$
%We know that \textit{the} $\KwRaise$ (if we get to it) is going to be handled by \textit{the} handler.
%And in that case, $x*2$ is going to be multiplied by $3$.
How to \textit{optimize} the program, so that we only perform one multiplication, $x*6$?

We can ask a similar question for \textit{effect handlers}.
This generalization allows us to capture the \textit{continuation} of the \textit{operation} (a.k.a.\,\textit{generic effect}) we are handling
and bind it as a variable.
The conventional evaluation step rule is
$$\Handle E[\Op v] \With x\;k.\,e ↦  e\subst{x}{v}\subst{k}{λy.\,\Handle E[y] \With x\;k.\,e} $$
This is a form of \textit{static delimited control}: control because we capture continuations,
delimited because the continuation is delimited by the handler, and static because the delimiter remains
in the captured continuation.
%The last part is crucial.

Let's consider a similar example:
$$ \Handle \Let{x}{e}{\Op (x*2)} \With z\;k.\,k\,(z*3) $$
Similarly to the example of exceptions, we know that $\Op (x*2)$ will be handled
by the $z\;k.\,k\,(z*3)$ handler -- even if continuation capture occurs during the execution of $e$,
the $\KwOp$ and the $\KwHandle$ will stay together.

We therefore know the substitution that will be performed during the handling of the operation:
$z:=x*2$. Exactly this substitution is needed to rewrite the two multiplications into one.
We also can deduce the substitution $k:=λy.\,\Handle y \With z\;k.\,k\,(z*3)$.
But we can't substitute those into the handler's clause, because the clause is shared for all operations inside,
and $x$ is not even in scope.

Since we know the clause that will run for the specific operation,
instead of performing it, we can \textit{abort} the handler and execute the clause specialized with the specific substitutions.
That is, rewrite the $\Op (z*2)$ into
$$\A\,(k\,(z*3))\subst{z}{x*2}\subst{k}{λy.\,\Handle y \With z\;k.\,k\,(z*3)},$$
where $\A$ is the new \textit{abort} expression former.
We get
$$\Handle \Let{x}{e}{\A\,\big((λy.\,\Handle y \With z\;k.\,k\,(z*3)) (x*2*3)\big)} \With z\;k.\,k\,(z*3)$$
which simplifies to
$$\Handle \Let{x}{e}{\A\,(x*6)} \With z\;k.\,k\,(z*3)$$

Of course, this poses questions such as ``where does the abort come from?''.
One can also imagine that the general rewrite rule for this would be rather complicated...

The issue with conventional syntax for operations and effect handlers is that
the operations are \textit{passive}.
In a real implementation, when we get to an operation, we immediately begin the search for a handler.
The syntax does not reflect that, it doesn't say what happens next. It's just an operation name and a payload value.

We will therefore base our calculus for optimizations on the other static delimited control operator:
$\shiftz$. The conventional rule for $\shiftz$ and its delimiter \textsf{reset} (written $⟨·⟩$) is:
$$⟨E[\shiftz\,k.\,e]⟩ ↦ e\subst{k}{λy.\,⟨E[y]⟩}$$
Here, the $\shiftz$ assumes the active role by initiating capture of continuation $k$ and carrying the expression $e$ that says what to do with it,
while the delimiter is passive -- it merely delimits.
We can now express \textsf{abort} simply as a $\shiftz$ that ignores the continuation: $\textsf{abort}\,e ≡ \shiftz\,\_.\,e$.

To express effect handlers, we will extend delimiters by letting them carry a value.
The value will be a lambda abstraction $λz\;k.\,e$ representing the handler's clause.
An operation will be a $\shiftz$ that explicitly asks for it and applies the payload and continuation.

Finally, to achieve fine-grained steps instead of complex rules that move entire contexts around,
we will get rid of the irregularity that is the $λ$-abstraction wrapping the continuation.
Delimited continuations will not be represented as call-by-value functions, but instead
as their own sort with the ability to plug in any expression, not just a value.
This lets us use structural substitution known from the $λμ$-calculus and all the benefits it brings \cite{benefit}.

\chapter{Syntax}

\begin{figure}
\begin{align*}
	v,u &::= x │ λx.\,e \\
	e,t &::= v │ v\;v │ \Let{x}{e}{t} │ \S κ.\,e │ ⟨e / v⟩ │ κ[e] │ \Ask(κ) \\
	E   &::= □ │ \Let{x}{E}{t}
\end{align*}
\caption{Syntax.}
\label{syntax}
\end{figure}

The syntax of the calculus is in figure \ref{syntax}.
We will be using a few shorthands:
\begin{enumerate}
	\item $\A\,e ≡ \S\_.\,e$, i.e. an abort: an $\S$ that ignores the captured continuation
	\item $f\;x\;y ≡ \Let{g}{f\;x}{g\;y}$
	\item $λx\,y.\,e ≡ λx.\,λy.\,e$
\end{enumerate}


We will use $\A\,e$ as a shorthand for $\S\_.\,e$, i.e.\, an $\S$ that ignores the captured continuation.
We have shifted away from the $\shiftz$/$\abort$ naming to differentiate from the variant that binds the continuation as a function and for brevity.

The operational semantics is in figure \ref{step}.
Let's use it verify the correctness of the macro-encodings we will be using:
$$\shiftz\,k.\,e ≡ \S κ.\,\Let{k}{λx.\,κ[x]}{e}$$
\begin{align*}
	⟨E[\shiftz\,k.\,e]⟩
	&≡ ⟨E[\S κ.\,\Let{k}{λx.\,κ[x]}{e}]⟩ \\
	&↦ \Let{k}{λx.\,⟨E[x]⟩}{e} ↦ e\subst{κ}{λx.\,⟨E[x]⟩}
\end{align*}

$$\Handle e \With x\,k.\,t ≡ ⟨e/λx\,k.\,t⟩$$
$$\Op v ≡ \S κ.\,{\Ask(κ)\;v\;(λx.\,κ[x])}$$

\begin{align*}
	\Handle E[\Op v] \With x\,k.\,t
	&≡ ⟨E[\S κ.\,\Ask(κ)\;v\;(λx.\,κ[x])]/λx\,k.\,t⟩] \\
	&↦ (λx\,k.\,t)\;v\;(λx.\,⟨E[x]/λx\,k.\,t⟩) \\
	&↦ (λk.\,t\subst{x}{v})\;(λx.\,⟨E[x]/λx\,k.\,t⟩) \\
	&↦ t\subst{x}{v}\subst{k}{λx.\,⟨E[x]/λx\,k.\,t⟩} \\
	&≡ t\subst{x}{v}\subst{k}{λx.\,\Handle E[x] \With x\,k.\,t}
\end{align*}

Many calculi take a \textit{return clause} to be an integral part of the delimiter.
We will denote it by tacking on $│ x.\,t_r$.
The defining evaluation rule is
$$\Handle v \With x\,k.\,t_h │ x.\,t_r ↦  t_r\subst{x}{v}$$
and similarly for the reset (with the return clause often called \textit{dollar}):
$$⟨v│x.\,t_r⟩ ↦ t_r\subst{x}{v}$$
In words, the $t_r$ is a part of the captured continuation,
but the delimiter is dropped when we execute it.

We encode it thus:
$$⟨e│x.\,t_r⟩ ≡ ⟨\Let{x}{e}{\A\,t_r}⟩$$
$$\Handle e \With x\,k.\,t_h │ x.\,t_r ≡ ⟨\Let{x}{e}{\A\,t_r}/λx\,k.\,t_h⟩$$
Verifying the evaluation rule is easy, here's the one for the effect handler:
\begin{align*}
	\Handle v \With x\,k.\,t_h │ x.\,t_r
	&≡ ⟨\Let{x}{v}{\A\,t_r}/λx\,k.\,t_h⟩ \\
	&↦ ⟨\A\,t_r\subst{x}{v}/λx\,k.\,t_h⟩ ↦ t_r\subst{x}{v}
\end{align*}




\begin{figure}
\begin{mathpar}
	\inferrule
		{}
		{(λx.\,e)\;v ↦ e\subst{x}{v}}

	\inferrule
		{}
		{\Let{x}{v}{t} ↦ t\subst{x}{v}}

	\inferrule
		{}
		{⟨v/u⟩ ↦ v}

	\inferrule
		{}
		{⟨E[\S κ.\,e]/v⟩ ↦ e\subst{κ}{⟨E/v⟩}}

	\inferrule
		{}
		{κ[E[\S κ'.\,e]] ↦ e\subst{κ'}{κ[E]}}

\end{mathpar}
\caption{Evaluation step.}
	\label{step}
\end{figure}

\begin{figure}
	\begin{mathpar}
		(λx.\,e)\,v → e\subst{x}{v}

		\Let{x}{v}{t} → t\subst{x}{v}

		⟨v/u⟩ → v

		κ[\S κ'.\,e] → e\subst{κ'}{κ}

		⟨\S κ.\,e / v⟩ → e\subst{κ}{⟨□/v⟩}

		\Let{x}{\S κ.\,e}{t} → \S κ.\,e\subst{κ}{κ[\Let{x}{□}{t}]}

		⟨L[\S κ.\,e]/v⟩ → ⟨L[A\,e\subst{κ}{⟨□/v⟩}]⟩

		⟨L[\A\,⟨e/v⟩]/v⟩ → ⟨L[e]/v⟩

		⟨L[\A\,u]/v⟩ → ⟨L[u]/v⟩

		\Let{x}{\Let{y}{e}{t_1}}{t_2} → \Let{y}{e}{\Let{x}{t_1}{t_2}}

	\end{mathpar}
	\caption{Reduction.}
\end{figure}




\chapter{Confluence}

We haven't managed to prove confluence for
the entire calculus.

We present a proof using the parallel reduction technique for the subcalculus without
data in delimiters and without let reassociation.

\section*{The problems with $\KwLet$ reassociation}

The $\KwLet$ reassociation reduction
$$\RLet{x}{\Let{y}{e}{t_1}}{t_2} → \Let{y}{e}{\Let{x}{t_1}{t_2}}$$
flattens the structure of the term by getting rid of $\KwLet$s nested on the left
(here raised).
It has the following critical pair with itself:
$$
\begin{tikzpicture}
	\node (E1) at (2,5) {$\RLet{x}{\RLet{y}{\Let{z}{e}{t_1}}{t_2}}{t_3}$};
	\node (E2) at (6,3) {$\RLet{y}{\Let{z}{e}{t_1}}{\Let{x}{t_2}{t_3}}$};
	\node (E3) at (0,2) {$\RLet{x}{\Let{z}{e}{\Let{y}{t_1}{t_2}}}{t_3}$};
	\node (E3') at (2,1) {$\Let{z}{e}{\RLet{x}{\Let{y}{t_1}{t_2}}}{t_3}$};
	\node (E4) at (4,0) {$\Let{z}{e}{\Let{y}{t_1}{\Let{x}{t_2}{t_3}}}$};
	\path[->]
		(E1) edge (E2)
		(E1) edge (E3);
	\path[->,dashed]
		(E2) edge[bend left] (E4)
		(E3) edge (E3')
		(E3') edge (E4);
	%\draw [brown] (current bounding box.south west) rectangle (current bounding box.north east);
\end{tikzpicture}
$$
Two steps are needed on the left to complete the diagram.
This calls for the following generalization, which can do it in one step and \textit{does} have the diamond property:
$$\Let{x}{L[t_1]}{t_2} → L[\Let{x}{t_1}{t_2}]$$
However, this is not enough for \textit{parallel} reduction.
Here, the redex above overlaps with two different redexes below:
$$
\begin{tikzpicture}
	\node (E1) at (0,0) {$\RLet{x}{\RLet{y}{\RLet{z}{\Let{w}{e}{t_1}}{t_2}}{t_3}}{t_4}$};
	\node (E2) at (5.3,1.1) {$\RLet{x}{\RLet{z}{\Let{w}{e}{t_1}}{\Let{y}{t_2}}{t_3}}{t_4}$};
	\node (E3) at (5.3,-1.1) {$\RLet{y}{\Let{w}{e}{\Let{z}{t_1}}{t_2}}{\Let{x}{t_3}}{t_4}$};
	\path[->] (E1.east) edge[] (E2.south);
	\path[->>] (E1.east) edge[] (E3.north);
	%\draw [brown] (current bounding box.south west) rectangle (current bounding box.north east);
\end{tikzpicture}
$$
To complete this diagram in one parallel reduction step, it would need to have not only length-wise, but also a depth-wise generalization
of $\KwLet$ reassociation.
We don't provide a definition here, since we haven't managed to prove any attempt right.

The other challenge is that a $let.\S$ reduction can tear apart a $let.let$ redex:
$$
\begin{tikzpicture}
	\node (E1) at (0,0) {$\Let{x}{\Let{y}{\S κ.\,e}{t_1}}{t_2}$};
	\node (E2) at (3.5,-2) {$\Let{y}{\S κ.\,e}{\Let{x}{t_1}{t_2}}$};
	\node (E3) at (-3.5,-1.333) {$\Let{x}{\S κ.\,e\subst{κ}{κ[\Let{y}{□}{t_1}]}}{t_2}$};
	\node (E3') at (-3.5,-2.666) {$\S κ.\,e\subst{κ}{κ[\Let{x}{\Let{y}{□}{t_1}}{t_2}]}$};
	\node (E4) at (0,-4) {$\S κ.\,e\subst{κ}{κ[\Let{y}{□}{\Let{x}{t_1}{t_2}}]}$};
	\path[->] (E1) edge (E2);
	\path[->] (E1) edge (E3);
	\path[->,dashed] (E3) edge (E3') (E2) edge (E4);
	\path[->>,dashed] (E3') edge (E4);
\end{tikzpicture}
$$
We need a successive $let.\S$ step to make the $let.let$ redexes whole, now after structural substitution.


Let's demonstrate the main challenges for proving confluence.
Previous proofs of confluence for $λμ$-calculi amounted to the diamond property of parallel reduction.
The problem with confluence is that structural reduction ($let.\S$) can tear redexes apart, as in:
$$\Let{x}{\Let{y}{\S κ.\,e}{t_1}}{t_2}$$
$$⟨L[\Let{x}{\S κ.\,e}{\S κ.\,t}]⟩$$
and additional structural reductions are needed to make the $let.let$%
%\footnote{
%	Herbelin and Zimmerman \cite{Herbelin} report no problems with the critical pair involving $let.\S$ and $let.let$.
%	$let.let$ by itself poses problems, with 
%	We believe that's because they used a rule $κ[\Let{x}{e}{t}] → \Let{x}{e}{κ[t]}$, which seems to be valid in the undelimited case.
%	This rule doesn't figure in the paper, but a similar one $z(\Let{x}{e}{t}) → \Let{x}{e}{zt}$ does.
%}
and $dlets.\S$ redexes whole again,
now inside $e$.
Conversely, the structural substitution can push the $k.\S$ redex apart:
$$κ[\S κ'.\,e]\subst{κ}{κ[\Let{x}{□}{t}]} = κ[\Let{x}{\S κ'.\,e}{t}]$$
Therefore a parallel reduction involving the entirety of the calculus needs to be generalized to involve multiple structural reduction steps in some places.
Naively, such a definition would need to recursively refer to a parallel reduction of a term \textit{after} structural substitution.
Such a term may be bigger than the original, which poses problems for inductive proofs.

The parallel reduction approach does work, however, for the subcalculus without $let.let$ and without delimiters carrying data.

We will prove confluence of $\xrightarrow{\lStr} ∪ \Rrightarrow$,
where $\xrightarrow{\lStr}$ are structural reductions and $\Rrightarrow$ is a parallel reduction
containing the other reductions,
by the method of decreasing diagrams \cite{dd}.
Confluence of $→$ will follow from ${→} ⊆ {\xrightarrow{Str} ∪ \Rrightarrow} ⊆ {→^*}$.

We label $e \xrightarrow{\lStr} e'$ by $(\lStr, e)$ and $e \Rrightarrow e'$ by $\lPar$ and order the labels thus:
for all $e$ set $\lPar > (\lStr, e)$ and for all $e, e'$ set $(\lStr, e) > (\lStr, e')$ iff $e \xrightarrow{\lStr}\mathrel{\vphantom{\to}^+} e'$.
We need to prove that the order on labels is well-founded and that we can complete the three kinds of local peaks
into decreasing valleys.\footnote{
	The proof scheme is essentially Exercise 14.2.25 in Terese \cite{Terese}.
}

\section*{Strong normalization of $\xrightarrow{Str}$}
Well-foundedness of the labels will follow from strong normalization of
$$\xrightarrow{Str} \;=\; \xrightarrow{let.\S} ∪ \xrightarrow{d.\S} ∪ \xrightarrow{k.\S}.$$
We adapt the approach of de Groote\cite{Groote}.

and the ``frame occurences''\footnote{
	We count the continuation frame before ($1$) and after the potential capture by a $\S κ.\, e$ ($\#_κ e$).
} $\#$ and ``continuation variable count'' $\#_κ$ as follows:
\begin{align*}
	\# X[\S κ. e] &= 1 + \#_κ e \\
	\# e &= 1 \text{ otherwise} \\
%	\\
	\#_κ x &= 0 \\
	\#_κ λx. e &= \#_κ e \\
	\#_κ \S κ'.\,e &= \#_κ e \\
	\#_κ v\;u &= \#_κ v + \#_κ u \\
	\#_κ \Let{x}{e}{t} &= \#_κ e + \# e · \#_κ t \\
	\#_κ ⟨e⟩ &= \#_κ e \\
	\#_κ κ[e] &= \#_κ e + \# e \\
	\#_κ κ'[e] &= \#_κ e
\end{align*}
where $X$ are ``free contexts'' that skip across $\S$-delimiter brackets:
$$X ::= □ │ \Let{x}{X}{t} │ ⟨X[\S κ.\,X]⟩ │ κ[X[\S κ'.\,X]]$$
The idea is a $\KwLet$ can be captured by a particular $\S$
iff the term can be written as $\Let{x}{X[\S κ. e]}{t}$, similarly for other continuation frames.

\begin{prop}
	If $κ$ doesn't occur in $e$, then $\#_κ e = 0$.
\end{prop}

\begin{lemma}
	If $κ'$ doesn't occur in $t$, then
	\begin{enumerate}[label=(\roman*),ref=\thelemma (\roman*)]
		\item $\# e\subst{κ'}{κ'[\Let{x}{□}{t}]} = \# e$
		\item ($κ≠κ'$) $\#_κ e\subst{κ'}{κ'[\Let{x}{□}{t}]} = \#_κ e + \#_{κ'} e · \#_κ t$
	\end{enumerate}
\end{lemma}
\begin{proof}
	Induction on $e$. Let $K$ stand for $κ'[\Let{x}{□}{t}]$.
	\begin{enumerate}[label=(\roman*),ref=\thelemma (\roman*)]
%		\item
%			\begin{enumerate}
%				\item $\# v\subst{κ'}{K} = 1 = \# v$
%				\item $\# \S κ.\,e\subst{κ'}{K}
%					= 1 + \# e\subst{κ'}{K} + \#_κ e\subst{κ'}{K}
%					\stackrel{\text{IH}}{=} 1 + \# e + (\#_κ e + \#_{κ'} e · \#_κ t)
%					= 1 + \# e + (\#_κ e + \#_{κ'} e · 0)
%					= \# \S κ.\,e$
%				\item $\# v\subst{κ'}{K}\;u\subst{κ'}{K} = 1 = \# v\;u$
%				\item $\# \Let{x}{e\subst{κ'}{K}}{t'\subst{κ'}{K}} = \# e\subst{κ'}{K} \stackrel{\text{IH}}{=} \# e = \# \Let{x}{e}{t'}$
%				\item $\# ⟨e\subst{κ'}{K}⟩ = \# e\subst{κ'}{K} \stackrel{\text{IH}}{=} \# e = \# ⟨e⟩$
%				\item $\# (κ'[e])\subst{κ'}{K} = \# κ'[\Let{x}{e\subst{κ'}{K}}{t}] = \# e\subst{κ'}{K} \stackrel{\text{IH}}{=} \# e = \# κ'[e]$
%				\item ($κ≠κ'$) $\# (κ[e])\subst{κ'}{K} = \# κ[e\subst{κ'}{K}] = \# e\subst{κ'}{K} \stackrel{\text{IH}}{=} \# e = \# κ[e]$
%			\end{enumerate}
		\item
			\begin{enumerate}
				\item $\#_κ x\subst{κ'}{K} = \#_κ x = 0 = \#_κ x + \#_{κ'} x · \#_κ t$
				\item $\#_κ λx.\,e\subst{κ'}{K} = \#_κ e\subst{κ'}{K} \stackrel{\text{IH}}{=}
					\#_κ e + \#_{κ'} e · \#_κ t = \#_κ λx.\,e + \#_{κ'} λx.\,e · \#_κ t$
				\item $\#_κ v\subst{κ'}{K}\;u\subst{κ'}{K} \stackrel{\text{IH}}{=} \#_κ v + \#_{κ'} v · \#_κ t + \#_κ u + \#_{κ'} u · \#_κ t
					= (\#_κ v + \#_κ u) + (\#_{κ'} v + \#_{κ'} u) · \#_κ t = \#_κ (v\; u) + \#_{κ'} (v\;u) · \#_κ t$
				\item $\#_κ \Let{y}{e\subst{κ'}{K}}{t'\subst{κ'}{K}} = \#_κ e\subst{κ'}{K} + \# e\subst{κ'}{K} · \#_κ t'\subst{κ'}{K}
					\stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t + \# e · (\#_κ t' + \#_{κ'} t' · \#_κ t)
					= \#_κ e + \# e · \#_κ t' + (\#_{κ'} e + \# e · \#_{κ'} t') · \#_{κ} t
					= \#_κ \Let{y}{e}{t'} + \#_{κ'} \Let{y}{e}{t'} · \#_κ t$
				\item $\#_κ ⟨e\subst{κ'}{K}⟩ = \#_κ e\subst{κ'}{K} \stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t
					= \#_κ ⟨e⟩ + \#_{κ'} ⟨e⟩ + \#_κ t$
				\item ($κ≠κ'$) $\#_κ (κ'[e])\subst{κ'}{K} = \#_κ κ'[\Let{x}{e\subst{κ'}{K}}{t}] = \#_κ \Let{x}{e\subst{κ'}{K}}{t}
					= \#_κ e\subst{κ'}{K} + \# e\subst{κ'}{K} · \#_κ t
					\stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t + \# e · \#_κ t
					= \#_κ e + \#_{κ'} e · \#_κ t + \# e · \#_κ t = \#_κ κ'[e] + \#_{κ'} κ'[e] · \#_κ t$
				\item ($κ≠κ''≠κ'$) $\#_κ (κ''[e])\subst{κ'}{K} = \#_κ κ''[e\subst{κ'}{K}] = \#_κ e\subst{κ'}{K}
					\stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t
					= \#_κ κ''[e] + \#_{κ'} κ''[e] · \#_κ t$
				\item ($κ≠κ'$) $\#_κ (κ[e])\subst{κ'}{K} = \#_κ κ[e\subst{κ'}{K}]
					= \#_κ e\subst{κ'}{K} + \# e\subst{κ'}{K}
					\stackrel{\text{IH}}{=} \#_κ e + \#_{κ'} e · \#_κ t + \# e
					= \#_κ κ[e] + \#_{κ'} κ[e] · \#_κ t$
%				\item ($κ = κ'$) $\#_{κ'} (κ'[e])\subst{κ'}{K} = \#_{κ'} κ'[\Let{x}{e\subst{κ'}{K}}{t}]
%					= \#_{κ'} \Let{x}{e\subst{κ'}{K}}{t} + \# \Let{x}{e\subst{κ'}{K}}{t}
%					= \#_{κ'} e\subst{κ'}{K} + \# e\subst{κ'}{K} · \#_{κ'} t + \# e\subst{κ'}{K}
%					\stackrel{\text{IH}}{=} \#_{κ'} e + \#_{κ'} e · \#_{κ'} t + \# e · \#_{κ'} t + \# e
%					= \#_{κ'} κ'[e] + \#_{κ'} κ'[e] · \#_{κ'} t $
			\end{enumerate}
	\end{enumerate}
\end{proof}

\begin{lemma}
	\item
	\begin{enumerate}[label=(\roman*),ref=\thelemma (\roman*)]
		\item $\# e\subst{κ'}{⟨□⟩} = \# e$
		\item ($κ ≠ κ'$) $\#_κ e\subst{κ'}{⟨□⟩} = \#_κ e$
%		\item $\#_κ e\subst{κ}{⟨□⟩} = 0$
	\end{enumerate}
\end{lemma}

\begin{lemma}
	\item
	\begin{enumerate}[label=(\roman*),ref=\thelemma (\roman*)]
		\item $\# e\subst{κ'}{κ''} = \# e$
		\item ($κ ≠ κ'$) $\#_κ e\subst{κ'}{κ''} = \#_κ e + \begin{cases}\#_{κ'} e & \text{ if }κ=κ''\\ 0 & \text{ if } κ≠κ''\end{cases}$
	\end{enumerate}
\end{lemma}

\begin{lemma}
	If $e \xrightarrow{Str} e'$, then
	\begin{enumerate*}[label=(\roman*),ref=\thelemma (\roman*)]
		\item $\#e ≥ \#e'$ and \label{str_cnt}
		\item $\#_κ e ≥ \#_κ e'$.
	\end{enumerate*}
\end{lemma}
\begin{proof}
	We check reductions at the root of the term, other cases follow by induction.
	\begin{enumerate}
		\item $\Let{x}{\S κ.\,e}{t} → \S κ.\,e\subst{κ}{κ[\Let{x}{□}{t}]}$ \\
		      $\#\Let{x}{\S κ.\,e}{t}
			  = 1 + \#_κ e
			  \stackrel{\#_κ t = 0}{=} 1 + \#_{κ} e + \#_{κ} e · \#_{κ} t
			  = 1 +\#_{κ} e\subst{κ}{κ[\Let{x}{□}{t}]}
			  > \# \S κ.\,e\subst{κ}{κ[\Let{x}{□}{t}]}$ \\
			  $\#_κ \Let{x}{\S κ'.\,e}{t} = \#_κ e + \#_{κ'} e · \#_κ t
			  = \#_κ e\subst{κ'}{κ'[\Let{x}{□}{t}]}
			  = \#_κ \S κ'.\,e\subst{κ'}{κ'[\Let{x}{□}{t}]}$
		\item $⟨\S κ.\,e⟩ → e\subst{κ}{⟨□⟩}$ \\
		      $\#⟨\S κ.\,e⟩ = \# e = \#e\subst{κ}{⟨□⟩}$ \\
			  $\#_κ ⟨\S κ'.\,e⟩ = \#_κ e = \#_κ e\subst{κ'}{⟨□⟩}$
		\item $κ'[\S κ.\,e] → e\subst{κ}{κ'}$ \\
			  $\#κ'[\S κ.\,e] = \# e = \# e\subst{κ}{κ'}$ \\
			  $\#_{κ'} κ'[\S κ.\,e] = \#_{κ'} e + \# \S κ.\,e = \#_{κ'} e + \#_κ e = \#_{κ'} e\subst{κ}{κ'}$\\
			  ($κ'' ≠ κ'$) $\#_{κ''} κ'[\S κ.\,e] = \#_{κ''} e = \#_{κ''} e\subst{κ}{κ'}$\\
	\end{enumerate}
\end{proof}

Define the norm $|·|$ as follows:
\begin{align*}
	|x| &= 1 \\
	|λx. e| &= |e| \\
	|\S κ. e| &= 1 + |e| \\
	|v\;u| &= |v| + |u| \\
	|\Let{x}{e}{t}| &= |e| + \# e ·|t| \\
	|⟨e⟩| &= |e| \\
	|κ[e]| &= |e|
\end{align*}

\begin{lemma}
	$|e\subst{κ}{κ[\Let{x}{□}{t}]}| = |e| + \#_κ e · |t|$
\end{lemma}
\begin{proof}
	\item
	\begin{enumerate}
		\item $|(κ[e])\subst{κ}{κ[\Let{x}{□}{t}]}| = |κ[\Let{x}{e\subst{κ}{κ[\Let{x}{□}{t}]}}{t}]|
			= |e\subst{κ}{κ[\Let{x}{□}{t}]}| +  \# e\subst{κ}{κ[\Let{x}{□}{t}]} · |t|
			\stackrel{\text{IH}}{=} |e| + \#_κ e · |t| + \# e · |t| = |κ[e]| + \#_κ κ[e] · |t|$
%		\item
%			If we had $|κ[e]| = |e| + \# e$. \\
%			$|(κ[e])\subst{κ}{κ[\Let{x}{□}{t}]}| = |κ[\Let{x}{e\subst{κ}{κ[\Let{x}{□}{t}]}}{t}]|
%			= |e\subst{κ}{κ[\Let{x}{□}{t}]}| + \# e\subst{κ}{κ[\Let{x}{□}{t}]} +  \# e\subst{κ}{κ[\Let{x}{□}{t}]} · |t|
%			\stackrel{\text{IH}}{=} |e| + \# e + \#_κ e · |t| + \# e · |t| = |κ[e]| + \#_κ κ[e] · |t|$

		\item ($κ' ≠ κ$) $|(κ'[e])\subst{κ}{κ[\Let{x}{□}{t}]}| = |κ'[e\subst{κ}{κ[\Let{x}{□}{t}]}]| =
			|e\subst{κ}{κ[\Let{x}{□}{t}]}]|
			\stackrel{\text{IH}}{=} |e| + \#_κ e · |t| = |κ'[e]|$

	\end{enumerate}
\end{proof}

\begin{theorem}
	If $e \xrightarrow{Str} e'$, then $|e| > |e'|$.
\end{theorem}
\begin{proof}
	We check reductions at the root of the term, other cases follow by induction and Lemma \ref{str_cnt}.
	\begin{enumerate}
		\item $\Let{x}{\S κ.\,e}{t} → \S κ.\,e\subst{κ}{κ[\Let{x}{□}{t}]}$ \\
		      $|\Let{x}{\S κ.\,e}{t}| = 1 + |e| + \# \S κ.\, e · |t|
			  = 1 + |e| + (1 + \#_κ e) · |t|
			  > 1 + |e| + \#_κ e · |t|
			  = 1 + |e\subst{κ}{κ[\Let{x}{□}{t}]}|
			  = |\S κ.\,e\subst{κ}{κ[\Let{x}{□}{t}]}|$
		\item $⟨\S κ.\,e⟩ → e\subst{κ}{⟨□⟩}$ \\
		      $|⟨\S κ.\,e⟩| = 1 + |e| > |e| = |e\subst{κ}{⟨□⟩}|$
		\item
			$κ'[\S κ.\,e] → e\subst{κ}{κ'}$ \\
			$|κ'[\S κ.\,e]| = 1 + |e| > |e| = |e\subst{κ}{κ'}|$
	\end{enumerate}
\end{proof}
\begin{corollary}
	$\xrightarrow{Str}$ is strongly normalizing.
\end{corollary}


\chapter{Adequacy}

\begin{theorem}[Standardization]
\end{theorem}
\begin{corollary} If $e →^* v$, then $e ↦^* v' →_i^* v$.
\end{corollary}
\begin{proof}
	By standardization and since $→_i$ can't turn a nonvalue into a value.
\end{proof}


\begin{theorem}
	If $e → e'$, then $e$ evals to a value iff $e'$ evals to a value.
\end{theorem}
\begin{proof}
%	We take the proof from Crary.

	If $e' ↦^* v$, then $e →^* v$. By corollary to stan we have $e ↦^* v' →_i^* v$.

	If $e ↦^* v$, then by confluence we have $v →^* v' ←^* e'$, where $v'$ must be a value
	because $→$ preserves valueness. By corollary to stan we have $e' ↦^* v'' →_i^* v'$.

\end{proof}

\begin{prop}[Stuck terms]
\end{prop}

\chapter{Abella mechanization}

\chapter{Related work}


\section*{Distributing delimiters}
There is a strand of work which tackles static delimited control from the opposite direction.
Whereas we use structural reduction so that S moves closer to the delimiter, that strand's defining feature is
the delimiter distributing over let expressions so that \textit{a} delimiter can meet the control operator:

There, the return clause is an integral part of the syntax. On a sequence of lets this becomes

We consider turning every let into a delimiter unsatisfactory, since delimiters usually have a much higher runtime cost than let bindings.

Because they lack structural reduction, those systems cannot perform the optimizations in examples TODO.
We show that translations from those calculi preserve equations (understood as the equivalence closure of reduction)
to argue that our calculus is more powerful.

\section*{shift0 calculus}
By reflection\cite{ppdp21} it follows that the original shift0 equational theory by Materzok is also less powerful,
but for completeness we show it directly.

\section*{Delimited $λμ$}

\section*{Confluence}

Proofs of confluence have been notoriously difficult since the beginning --
the many early attempts for the $λ$-calculus were flawed.

The proof alongside the introduction of the $λμ$-calculus \cite{parigot92} also turned out to be incorrect \cite{baba}.
The fix involves performing multiple structural reduction steps \cite{baba,koji}, which we have employed in our formalization
and verified that it works also with our tail-of-delimiter reductions.

Herbelin and Zimmerman \cite{Herbelin} claim that a proof by parallel reduction is possible for a $λμ$-calculus with
$\KwLet$ reassociation, but provide no details. We don't see how they could deal with the $let.\S$-$let.let$ critical pair
unless they add a $κ[\Let{x}{e}{t}] → \Let{x}{e}{κ[t]}$ reduction, which is similar to theirs
$x(\Let{x}{e}{t}) → \Let{x}{e}{xt}$ and seems to be valid in the undelimited setting.

The proof in \cite{ppdp21} is claimed by local confluence of $\Rightarrow$ such that $→^*=\Rightarrow^*$,
which is not a valid argument (take $\Rightarrow=→$ for a counterexample, it is known that local confluence does not imply confluence). Diamond property is needed instead of local confluence.



\section*{Tail reductions and letcc}
The central idea in our paper is the reduction
$$⟨L[\S κ.\,e]⟩ → ⟨L[\A\,e\subst{κ}{⟨□⟩}]⟩$$
It can be tempting to decompose $\S$ into its constituent parts:
a $\keyword{letcc}$ which binds the continuation without aborting, and an abort $\A$:
$$\S κ.\,e ≡ \keyword{letcc}\;κ.\,\A\,e$$
Then we could simulate $dL.\S$ using a reduction that pushes $\keyword{letcc}$ out of the tail:
$$\Let{x}{e}{\keyword{letcc}\;κ.\,t} → \keyword{letcc}\;κ.\,\Let{x}{e}{t}$$
Analogous reductions have been considered for undelimited continuations.

There are issues with this approach, though:
\begin{enumerate}

	\item
Because $\keyword{letcc}$ binds the continuation and keeps running in it
$$⟨E[\keyword{letcc}\;κ.\,e]⟩ ↦ ⟨E[e\subst{κ}{⟨E⟩}]⟩$$
it is inherently incompatible with one-shot (linear) continuations.
This is a design choice or a limitation of some implementations of control, e.g.\,OCaml 5.
\item
Perhaps more importantly, the above reduction isn't semantics-preserving. If $e$ above is the nonterminating $Ω$,
then the left side diverges, while the right side gets stuck on searching for a delimiter.
Of course we could ensure a delimiter is found by performing the reduction only in $⟨L⟩$,
but then there are few benefits to this approach.
\end{enumerate}


\section*{Expressing return clauses}
Recall our encoding of return clauses:
$$⟨e│x.\,e_r⟩ ≡ ⟨\Let{x}{e}{\A\;e_r}⟩$$
$$\Handle e \With x,k.\,e_h │ x.\,e_r ≡ ⟨\Let{x}{e}{\A\;e_r}│λx,k.\,e_h⟩$$
An equivalence reminiscent of it has been proven for typed algebraic effects \cite{hwc}:
$$\Handle e \With x,k.\,e_h │ x.\,e_r ≈\Handle \Let{x}{e}{\Lift{e_r}} \With x,k.\,e_h$$
After $e$ has finished evaluating and we start evaluating the rhs of $\KwLet$,
we know that the frame at the top of the stack will be the handler.
So instead of adding a $\KwLift$ stack frame that makes effects skip the $\KwLift$-handler pair \cite[Appendix A]{hwc},
we can just pop the handler with an $\A$ for an equivalent result.
Our approach is therefore slightly more space- and time-efficient.

\chapter{Discussion and future work}

While this work brings forth many new ideas, it is far from being the IR of a compiler.

We believe all results transfer to multi-prompt delimited control, where we have independent sets of labeled operators $S^\ell κ. e$, $⟨e⟩^\ell$.
This is necessary for working with multiple effects, though the lift construct can to some extent simulate that.
Naturally, the purity assertions also could be refined to block or allow specific listed effects.
The multi-prompt calculus need a mild form of typing: in the renaming reduction we need to know that the continuation variable $κ$ comes
from an $\S$ with the matching label
$$κ^\ell[\S^\ell κ'.\,e] → e\subst{κ'}{κ}$$

One could wonder why we don't have tail-of-plug reductions
$$κ[L[\S κ'.\,e]] → κ[L[A\,e\subst{κ'}{κ}]]$$
The reason is they don't work in the multi-prompt setting.
If $κ$ is allowed to have delimiters of different labels in the middle, then
the continuation may not be intact by the time we get to the $\S$.

It should be clear that the central idea of this work, the tail-of-delimiter reductions,
doesn't apply to \textit{dynamic} delimited control.
They are those that make the delimiter disappear after capture, for example \textsf{control\textsubscript{0}}:
$$⟨E[\mathsf{control_0} κ.\,e]⟩ ↦ e\subst{κ}{E}$$
The only hope for optimizations seems to be purity-aware reductions,
which could move the delimiter directly to the operator. The same applies to the related \textit{shallow} effect handlers.
There is however an option between shallow and deep handlers: \textit{sheep} handlers \cite{sheep},
where the delimiter is static,
but the dynamically bound interpretation of the effect can be used at most once
and has to be manually reinstated every time a continuation is installed.




Realistic languages also have more tail contexts such as $if b then □ else □$ as well as evaluation contexts.

join points?

%\hfuzz=1pt
\printbibliography[heading=bibintoc]

\end{document}
